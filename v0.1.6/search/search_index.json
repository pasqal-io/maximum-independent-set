{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Maximum independent set","text":"<p>The Maximum Independent Set (MIS) library provides a flexible, powerful, and user-friendly Python interface for solving Maximum Independent Set problem using Quantum technologies. It is designed for scientists and engineers working on optimization problems\u2014no quantum computing knowledge required and no quantum computer needed for testing.</p> <p>This library lets users treat the solver as a black box: feed in a graph, get back an optimal (or near-optimal) independent set. For more advanced users, it offers tools to fine-tune algorithmic strategies, leverage quantum hardware via the Pasqal cloud, or even experiment with custom quantum sequences and processing pipelines.</p> <p>Users setting their first steps into quantum computing will learn how to implement the core algorithm in a few simple steps and run it using the Pasqal Neutral Atom QPU. More experienced users will find this library to provide the right environment to explore new ideas - both in terms of methodologies and data domain - while always interacting with a simple and intuitive QPU interface.</p> <p>For a more extensive overview of interesting classes of problems a quantum MIS solution is a good fit for, the reader is invited to peruse[^1].</p>"},{"location":"#getting-in-touch","title":"Getting in touch","text":"<ul> <li>Pasqal Community Portal (forums, chat, tutorials, examples, code library).</li> <li>GitHub Repository (source code, issue tracker).</li> <li>Professional Support (if you need tech support, custom licenses, a variant of this library optimized for your workload, your own QPU, remote access to a QPU, ...)</li> </ul>"},{"location":"#contribute","title":"Contribute","text":"<p>The GitHub repository is open for contributions!</p> <p>Don't forget to read the Contributor License Agreement.</p>"},{"location":"#references","title":"References","text":"<p>[^1] P. Cazals et al. arXiv:2502.04291 (2025)</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/","title":"Contributor Agreement","text":"<p>PASQAL CONTRIBUTION AGREEMENT (the \u201cAgreement\u201d)</p> <p>The author of the License is:   Pasqal, a Soci\u00e9t\u00e9 par Actions Simplifi\u00e9e (Simplified Joint Stock Company) registered under number 849 441 522 at the Registre du commerce et des soci\u00e9t\u00e9s (Trade and Companies Register) of Evry \u2013 France, headquartered at 24 rue \u00c9mile Baudot \u2013 91120 \u2013 Palaiseau \u2013 France, duly represented by its Pr\u00e9sident, M. Georges-Olivier REYMOND, Hereafter referred to as \u00ab the Licensor \u00bb</p> <p>In the course of its activities, Pasqal carries out and leads quantic projects, in their software components. These projects aim to bring together a community of like-minded individuals to contribute to the development and improvement of Pasqal\u2019s products. Pasqal clearly outlines which projects are open to contributions (\u201cProjects\u201d).</p> <p>This Agreement documents the rights granted by Contributors to Pasqal and is legally binding.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-1-definitions","title":"Article 1 Definitions","text":"<p>You, Your or Contributor : means the intellectual property rights owner or legal entity authorized by the intellectual property rights owner that is entering into this Agreement with\u00a0Pasqal</p> <p>Contribution : means any work, protected or not, that is submitted by You to Pasqal in which You own or assert ownership of the intellectual property rights, subject to proprietary licensing terms, and not otherwise distributer through an open-source license.</p> <p>Material : means the work object of the Project, made available by Pasqal to third parties. When this Agreement covers more than one Project, the Material means the work to which the Contribution was Submitted. After You Submit the Contribution, it may be included in any type of Material.</p> <p>Submit : means any form of electronic, verbal, or written communication sent to Pasqal or its representatives, including but not limited to electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, Pasqal for the purpose of discussing and improving the Material.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-2-entering-into-this-agreement","title":"Article 2 Entering into this Agreement","text":"<p>By Submitting any Contribution to Pasqal, You agree to enter into the Agreement with this entity, and be bound by the following terms.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-3-limitations-as-to-the-licensing-of-contributions","title":"Article 3 Limitations as to the licensing of Contributions","text":"<p>You guarantee that any Contribution You Submit to any Project is not licensed under any type of contaminating (even weakly contaminating) license, and that Pasqal will be free to combine your Contribution into any type of Material, for any Project, without any risk of contamination of said Material and/or Project.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-4-granting-of-a-copyright-andor-authors-rights-license","title":"Article 4 Granting of a Copyright and/or author\u2019s rights License","text":"<p>Subject to the terms and conditions of this Agreement, You hereby grant to Pasqal and to recipients of any Project distributed by Pasqal a worldwide, sublicensable, non-exclusive, royalty-free license to reproduce, prepare derivative works of, publicly display, publicly perform, and distribute Your Contributions and your Contribution in combination with the Material for the entire duration of the rights under Applicable law.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-5-granting-of-a-patent-license","title":"Article 5 Granting of a patent license","text":"<p>Subject to the terms and conditions of this Agreement, You grant Pasqal a, worldwide, non-exclusive, transferable, royalty free patent license, with the right to sublicense these rights to third parties, to make, have made, use, sell, offer for sale, import and otherwise  transfer the Contribution and the Contribution in combination with the Material for the entire duration of the rights under Applicable law, if the Contribution implies the implementation of any such patent.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-6-licensing-of-the-material-and-contribution","title":"Article 6 Licensing of the Material and Contribution","text":"<p>Based on the rights granted in articles 2 and 3, if Pasqal includes Your Contribution in a Material, Pasqal may license Material including Your Contribution under any license, whether permissive, weakly contaminating, or contaminating. Pasqal will respect Your moral rights in relation to Your Contribution as provided under the Applicable law.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-7-warranties-and-disclaimer","title":"Article 7 Warranties and disclaimer","text":"<p>You represent that each of Your Contributions is Your creation, or that you have obtained the authorization from the intellectual property rights owner on the Contribution to Submit it over the course of a Project.</p> <p>By making a Contribution, You confirm that, to the best of Your knowledge, the Contribution does not violate the rights of any person or entity. If You make a Contribution on behalf of Your employer, then You confirm that an appropriate representative of that employer has authorized the inclusion of such Contribution to a Project and that it meets these requirements.</p> <p>You acknowledge that Pasqal is not obligated to use Your Contribution as part of the Material and may decide to only include Contributions Pasqal considers appropriate.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-8-applicable-law-and-jurisdiction","title":"Article 8 Applicable law and jurisdiction","text":"<p>The Agreement is governed by the laws of France. Any dispute relating to the interpretation or application of the License shall be subject to best efforts for an amicable settlement. Any dispute relating to the License, notably its execution, performance and/or termination shall be brought to, heard and tried by the Tribunal Judiciaire de Paris, regardless of the rules of jurisdiction in the matter.</p>"},{"location":"LICENSE/","title":"Licence (MIT-Derived)","text":"<p>PASQAL OPEN-SOURCE SOFTWARE LICENSE AGREEMENT (MIT-derived)</p> <p>The author of the License is:   Pasqal, a Soci\u00e9t\u00e9 par Actions Simplifi\u00e9e (Simplified Joint Stock Company) registered under number 849 441 522 at the Registre du commerce et des soci\u00e9t\u00e9s (Trade and Companies Register) of Evry \u2013 France, headquartered at 24 rue \u00c9mile Baudot \u2013 91120 \u2013 Palaiseau \u2013 France, duly represented by its Pr\u00e9sident, M. Georges-Olivier REYMOND, Hereafter referred to as \u00ab the Licensor \u00bb</p> <ul> <li> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software (the \u201cLicensee\u201d) and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. The Software is \u201cas is\u201d, without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and non-infringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise arising from, out of or in connection with the Software or the use or other dealings in the Software.</p> </li> <li> <p>If use of the Software leads to the necessary use of any patent of the Licensor and/or any of its Affiliates (defined as a company owned or controlled by the Licensor), the Licensee is granted a royalty-free license, in any country where such patent is in force, to use the object of such patent; or use the process covered by such patent,</p> </li> <li> <p>Such a patent license is granted for internal research or academic use of the Licensee's, which includes use by employees and students of the Licensee, acting on behalf of the Licensee, for research purposes only.</p> </li> <li> <p>The License is governed by the laws of France. Any dispute relating to the License, notably its execution, performance and/or termination shall be brought to, heard and tried by the Tribunal Judiciaire de Paris, regardless of the rules of jurisdiction in the matter.</p> </li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#using-hatch-uv-or-any-pyproject-compatible-python-manager","title":"Using <code>hatch</code>, <code>uv</code> or any pyproject-compatible Python manager","text":"<p>In your project, edit file <code>pyproject.toml</code> to add the line</p> <pre><code>  \"maximum-independent-set\"\n</code></pre> <p>to the list of <code>dependencies</code>.</p>"},{"location":"installation/#using-pip-or-pipx","title":"Using <code>pip</code> or <code>pipx</code>","text":"<p>To install the <code>pipy</code> package using <code>pip</code> or <code>pipx</code></p> <ol> <li>Create a <code>venv</code> if that's not done yet</li> </ol> <pre><code>$ python -m venv venv\n</code></pre> <ol> <li>Enter the venv</li> </ol> <pre><code>$ . venv/bin/activate\n</code></pre> <ol> <li>Install the package</li> </ol> <pre><code>$ pip install maximum-independent-set\n# or\n$ pipx install maximum-independent-set\n</code></pre>"},{"location":"tutorial%201%20-%20Using%20a%20Quantum%20Device%20to%20solve%20MIS/","title":"Tutorial 1 - Using a Quantum Device to solve MIS","text":"<p>Maximum Independent Set (MIS) is a standard and widespread graph problem in scheduling, network theory, error correction, and even in the quantum sector as part of more general optimization algorithms (e.g., QUBO formulations) or as a benchmark on quantum annealers or neutral atom devices.</p> <p>There is currently no known polynomial-time algorithm for general graphs running on classical (non-quantum) devices, which means that, in practice, finding an exact solution for large graphs is generally not possible due to time and hardware limitations. For this reason, most applications of MIS must satisfy themselves with finding approximate solutions. As it turns out, in some cases, even finding approximate solutions is considered hard. For these reasons, there is high interest in solving MIS on Quantum Devices.</p> <p>This library does just that: it compiles an MIS into a form suited for execution on existing analog quantum hardware, such as the commercial QPUs produced by Pasqal. No knowledge of quantum programming is necessary and no quantum computer is needed to test-drive the library. In this tutorial, we will walk you through executing an instance of MIS, using both classical and quantum methods.</p> <p>By the end of this notebook, you will know how to:</p> <ul> <li>Setup import for standard MIS benchmarking DIMACS datasets.</li> <li>Setup compilation and execution of these graphs for execution on both Classical and Quantum Device (either an emulator or a physical QPU).</li> <li>Launch the execution and extract relevant results.</li> </ul> <p>As in any MIS process, we first need to load and prepare data in a suitable graph format. For this tutorial, we will use the standard benchmark DIMACS datasets of various sizes and convert them to supported Networkx graph types.</p> In\u00a0[1]: Copied! <pre># Ignore warnings for this tutorial.\nimport logging\nimport os\nimport sys\n\nlogger = logging.getLogger()\nlogger.disabled = True\n\nsys.stderr = open(os.devnull, 'w')\n</pre> # Ignore warnings for this tutorial. import logging import os import sys  logger = logging.getLogger() logger.disabled = True  sys.stderr = open(os.devnull, 'w') In\u00a0[2]: Copied! <pre>import networkx as nx\n\n# Create a new networkx graph instance to be populated with DIMACS data.\ngraph = nx.Graph()\n\n\nwith open(\"./datasets/dimacs/a265032_1tc.32.txt\", \"r\") as f:\n    for line in f:\n        if line.startswith(\"c\"):  # Comment line in DIMACS file.\n            continue\n        elif line.startswith(\"p\"):  # Problem definition, i.e. # nodes and edges.\n            _, _, num_nodes, num_edges = line.strip().split()\n            # Preset graph node labels as there might be isolated ones.\n            graph.add_nodes_from(range(1, int(num_nodes) + 1))\n\n        elif line.startswith(\"e\"):\n            _, node1, node2 = line.strip().split()\n            graph.add_edge(int(node1), int(node2))\n\n# Let's check what the graph looks like.\nprint(graph)\n</pre> import networkx as nx  # Create a new networkx graph instance to be populated with DIMACS data. graph = nx.Graph()   with open(\"./datasets/dimacs/a265032_1tc.32.txt\", \"r\") as f:     for line in f:         if line.startswith(\"c\"):  # Comment line in DIMACS file.             continue         elif line.startswith(\"p\"):  # Problem definition, i.e. # nodes and edges.             _, _, num_nodes, num_edges = line.strip().split()             # Preset graph node labels as there might be isolated ones.             graph.add_nodes_from(range(1, int(num_nodes) + 1))          elif line.startswith(\"e\"):             _, node1, node2 = line.strip().split()             graph.add_edge(int(node1), int(node2))  # Let's check what the graph looks like. print(graph)  <pre>Graph with 32 nodes and 68 edges\n</pre> <p>Let's first solve this instance of MIS using standard heuristics.</p> In\u00a0[3]: Copied! <pre>from mis import MISSolver, MISInstance, SolverConfig\n# Define classical solver configuration\n\n# Use a default configuration for the library.\n# By default, the library uses a classical (non-quantum)\n# heuristic solver.\nconfig = SolverConfig()\n\n# Create the MIS instance.\ninstance = MISInstance(graph)\n\n# Run the solver and retrieve results.\nsolver = MISSolver(instance, config)\nsolutions = solver.solve()\n\n# Display results\nsolutions[0].draw()\nprint(\"Solution nodes: \", solutions[0].nodes)\nprint(\"Solution frequency:\", solutions[0].frequency)\nprint(\"Solution size:\", solutions[0].size)\n</pre> from mis import MISSolver, MISInstance, SolverConfig # Define classical solver configuration  # Use a default configuration for the library. # By default, the library uses a classical (non-quantum) # heuristic solver. config = SolverConfig()  # Create the MIS instance. instance = MISInstance(graph)  # Run the solver and retrieve results. solver = MISSolver(instance, config) solutions = solver.solve()  # Display results solutions[0].draw() print(\"Solution nodes: \", solutions[0].nodes) print(\"Solution frequency:\", solutions[0].frequency) print(\"Solution size:\", solutions[0].size) <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>Solution nodes:  [1, 2, 4, 8, 9, 15, 16, 18, 25, 26, 30, 32]\nSolution frequency: 1.0\nSolution size: 12\n</pre> <p>In this instance, we have used the default (non-quantum) solver. This solver is based on the approximate MIS solver in Networkx. From its inherent heuristic and non-deterministic nature, this solver does not guarantee optimality in solution finding.</p> <p>The solver returns a list of node labels of size 12 which is the unique solution so far (frequency of 1.0).</p> <p>In the previous section, we have used a non-quantum solver to resolve our instance of MIS. In this section, we'll use actually use a quantum algorithm. There are three steps to quantum algorithms:</p> <ol> <li>Converting the problem into a Register (the position of atoms in the quantum device) and a set of Pulses (the configuration of lasers on the quantum device)</li> <li>Actually running the Register and Pulse on the quantum device</li> <li>Extracting the results of quantum measurement on the quantum device into a solution to the original problem.</li> </ol> <p>In this library, all three steps are entrusted to backends. This library provides several backends, depending on your use. Since you may not have access to a quantum computer for step 2, we will use the <code>QutipBackend</code>. This is a simple backend that has the advantage of working on most computers, regardless of operating system or GPU.</p> In\u00a0[4]: Copied! <pre>from mis import BackendConfig, BackendType\n\n\nsolver_config = SolverConfig(\n    # Use the QuTIP backend.\n    backend = BackendConfig(\n        backend = BackendType.QUTIP\n    ),\n    # Perform up to 10 quantum measures.\n    max_iterations=10\n)\n\n# Run the solver\nsolver = MISSolver(instance, config)\nsolutions = solver.solve()\n\n# Display results\nprint(\"MIS solution:\", solutions[0].nodes)\nprint(\"Solution frequency:\", solutions[0].frequency)\nprint(\"Solution size:\", solutions[0].size)\nsolutions[0].draw()\n</pre> from mis import BackendConfig, BackendType   solver_config = SolverConfig(     # Use the QuTIP backend.     backend = BackendConfig(         backend = BackendType.QUTIP     ),     # Perform up to 10 quantum measures.     max_iterations=10 )  # Run the solver solver = MISSolver(instance, config) solutions = solver.solve()  # Display results print(\"MIS solution:\", solutions[0].nodes) print(\"Solution frequency:\", solutions[0].frequency) print(\"Solution size:\", solutions[0].size) solutions[0].draw() <pre>MIS solution: [1, 2, 4, 8, 9, 15, 16, 18, 25, 26, 30, 32]\nSolution frequency: 1.0\nSolution size: 12\nfindfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <p>Note that any quantum algorithm is, by definition, non-deterministic, so there is no guarantee that this will be the same solution as the non-quantum solver.</p> In\u00a0[5]: Copied! <pre># Replace with your username, project id and password on the Pasqal Cloud.\nUSERNAME=\"username\"\nPROJECT_ID=\"123\"\nPASSWORD=None\n\nif PASSWORD is not None:\n    config = SolverConfig(\n        backend = BackendConfig(\n            backend=BackendType.REMOTE_QPU,\n            username=USERNAME,\n            project_id=PROJECT_ID,\n            password=PASSWORD\n        ),\n        max_iterations=10\n    )\n\n    # Run the solver\n    solver = MISSolver(instance, config)\n    solutions = solver.solve()\n\n    # Display results\n    print(\"MIS solution:\", solutions[0].nodes)\n    print(\"Solution cost:\", solutions[0].frequency)\n    solutions[0].draw()\n</pre>  # Replace with your username, project id and password on the Pasqal Cloud. USERNAME=\"username\" PROJECT_ID=\"123\" PASSWORD=None  if PASSWORD is not None:     config = SolverConfig(         backend = BackendConfig(             backend=BackendType.REMOTE_QPU,             username=USERNAME,             project_id=PROJECT_ID,             password=PASSWORD         ),         max_iterations=10     )      # Run the solver     solver = MISSolver(instance, config)     solutions = solver.solve()      # Display results     print(\"MIS solution:\", solutions[0].nodes)     print(\"Solution cost:\", solutions[0].frequency)     solutions[0].draw()"},{"location":"tutorial%201%20-%20Using%20a%20Quantum%20Device%20to%20solve%20MIS/#tutorial-1-using-a-quantum-device-to-solve-mis","title":"Tutorial 1 - Using a Quantum Device to solve MIS\u00b6","text":""},{"location":"tutorial%201%20-%20Using%20a%20Quantum%20Device%20to%20solve%20MIS/#the-mis-problem","title":"The MIS problem\u00b6","text":"<p>The MIS problem can be formulated as follows: given a graph $G=(V,E)$, an independent set is a subset of vertices $S\\subseteq V$ such that no two vertices in $S$ are connected by an edge. The MIS problem then seeks to find the largest independent set in $G$.</p>"},{"location":"tutorial%201%20-%20Using%20a%20Quantum%20Device%20to%20solve%20MIS/#dataset-preparation","title":"Dataset preparation\u00b6","text":""},{"location":"tutorial%201%20-%20Using%20a%20Quantum%20Device%20to%20solve%20MIS/#solving-mis-using-a-non-quantum-solver","title":"Solving MIS using a non-quantum solver\u00b6","text":""},{"location":"tutorial%201%20-%20Using%20a%20Quantum%20Device%20to%20solve%20MIS/#solving-using-the-quantum-sdk-qutip","title":"Solving using the quantum SDK QuTiP\u00b6","text":""},{"location":"tutorial%201%20-%20Using%20a%20Quantum%20Device%20to%20solve%20MIS/#solving-using-remote-qpu-backend","title":"Solving using Remote QPU backend\u00b6","text":"<p>This section illustrates the use of a QPU backend hosted on Pasqal's Cloud Platform. Provided that you are granted with credentials to access the platform, they should be passed to instantiate a <code>RemoteQPUBackend</code>.</p>"},{"location":"tutorial%202%20-%20Using%20GreedyMIS%20to%20take%20better%20advantage%20of%20Quantum%20Hardware/","title":"Tutorial 2 - GreedyMIS Example Use Case","text":"<p>Generating a random graph and basic parameters for greedy algorithm.</p> In\u00a0[1]: Copied! <pre>from mis.shared.types import MISInstance, MethodType\nfrom mis.pipeline.config import BackendConfig, BackendType, SolverConfig, GreedyConfig\nfrom mis import MISSolver\nfrom mis.shared.graphs import is_independent\n</pre> from mis.shared.types import MISInstance, MethodType from mis.pipeline.config import BackendConfig, BackendType, SolverConfig, GreedyConfig from mis import MISSolver from mis.shared.graphs import is_independent In\u00a0[2]: Copied! <pre>from networkx import erdos_renyi_graph\n\n# User can fix the seed for reproducibility \nseed = 0\ngraph = erdos_renyi_graph(n=25, p=0.4, seed=seed)\n</pre> from networkx import erdos_renyi_graph  # User can fix the seed for reproducibility  seed = 0 graph = erdos_renyi_graph(n=25, p=0.4, seed=seed) <p>Note: The solution size reflects the total numbers of nodes of the maximum independent set (MIS). Thus, the solution size equals the cardinality (size) of the independent set.</p> In\u00a0[3]: Copied! <pre>instance = MISInstance(graph)\n\nconfig = SolverConfig(method=MethodType.EAGER)\nsolver = MISSolver(instance, config)\nsolution = solver.solve()[0]\n\nprint(\"Classical MIS (no greedy):\", solution.nodes)\nprint(\"Solution size:\", solution.size)\nprint(\"Independence check: \", is_independent(instance.graph, solution.nodes))\nsolution.draw()\n</pre> instance = MISInstance(graph)  config = SolverConfig(method=MethodType.EAGER) solver = MISSolver(instance, config) solution = solver.solve()[0]  print(\"Classical MIS (no greedy):\", solution.nodes) print(\"Solution size:\", solution.size) print(\"Independence check: \", is_independent(instance.graph, solution.nodes)) solution.draw() <pre>Classical MIS (no greedy): [0, 3, 7, 9, 11, 14, 23, 24]\nSolution size: 8\nIndependence check:  True\nfindfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> In\u00a0[4]: Copied! <pre>config = SolverConfig(method=MethodType.GREEDY)\nsolver = MISSolver(instance, config)\nsolution = solver.solve()[0]\n\nprint(\"Classical MIS (greedy):\", solution.nodes)\nprint(\"Solution size:\", solution.size)\nprint(\"Independence check: \", is_independent(instance.graph, solution.nodes))\nsolution.draw()\n</pre> config = SolverConfig(method=MethodType.GREEDY) solver = MISSolver(instance, config) solution = solver.solve()[0]  print(\"Classical MIS (greedy):\", solution.nodes) print(\"Solution size:\", solution.size) print(\"Independence check: \", is_independent(instance.graph, solution.nodes)) solution.draw() <pre>Classical MIS (greedy): [2, 13, 20, 10, 21, 24]\nSolution size: 6\nIndependence check:  True\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> In\u00a0[5]: Copied! <pre>config = SolverConfig(method=MethodType.GREEDY, greedy=GreedyConfig(default_solving_threshold=20, subgraph_quantity=10))\nsolver = MISSolver(instance, config)\nsolution = solver.solve()[0]\n\nprint(\"Classical MIS (greedy):\", solution.nodes)\nprint(\"Solution size:\", solution.size)\nprint(\"Independence check: \", is_independent(instance.graph, solution.nodes))\nsolution.draw()\n</pre> config = SolverConfig(method=MethodType.GREEDY, greedy=GreedyConfig(default_solving_threshold=20, subgraph_quantity=10)) solver = MISSolver(instance, config) solution = solver.solve()[0]  print(\"Classical MIS (greedy):\", solution.nodes) print(\"Solution size:\", solution.size) print(\"Independence check: \", is_independent(instance.graph, solution.nodes)) solution.draw() <pre>Classical MIS (greedy): [18, 6, 0, 2, 11, 15, 24]\nSolution size: 7\nIndependence check:  True\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> In\u00a0[6]: Copied! <pre>backend_config = BackendConfig(\n    backend=BackendType.QUTIP\n)\nconfig = SolverConfig(method=MethodType.EAGER, backend=backend_config)\nsolver = MISSolver(instance, config)\nsolution = solver.solve()[0]\n\nprint(\"Quantum MIS (no greedy):\", solution.nodes)\nprint(\"Solution size:\", solution.size)\nprint(\"Independence check: \", is_independent(instance.graph, solution.nodes))\nsolution.draw()\n</pre> backend_config = BackendConfig(     backend=BackendType.QUTIP ) config = SolverConfig(method=MethodType.EAGER, backend=backend_config) solver = MISSolver(instance, config) solution = solver.solve()[0]  print(\"Quantum MIS (no greedy):\", solution.nodes) print(\"Solution size:\", solution.size) print(\"Independence check: \", is_independent(instance.graph, solution.nodes)) solution.draw() <pre>Quantum MIS (no greedy): [0, 3, 7, 9, 11, 14, 23, 24]\nSolution size: 8\nIndependence check:  True\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> In\u00a0[7]: Copied! <pre>config = SolverConfig(\n    method=MethodType.GREEDY,\n    backend=backend_config,\n)\nsolver = MISSolver(instance, config)\nsolution = solver.solve()[0]\n\nprint(\"Quantum MIS (greedy):\", solution.nodes)\nprint(\"Solution size:\", solution.size)\nprint(\"Independence check: \", is_independent(instance.graph, solution.nodes))\nsolution.draw()\n</pre> config = SolverConfig(     method=MethodType.GREEDY,     backend=backend_config, ) solver = MISSolver(instance, config) solution = solver.solve()[0]  print(\"Quantum MIS (greedy):\", solution.nodes) print(\"Solution size:\", solution.size) print(\"Independence check: \", is_independent(instance.graph, solution.nodes)) solution.draw() <pre>Quantum MIS (greedy): [0, 3, 7, 9, 11, 14, 22, 23]\nSolution size: 8\nIndependence check:  True\nfindfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <p>You can fine-tune the decomposition process using:</p> <ul> <li>default_solving_threshold: size of the solve small subgraphs to solve directly.</li> <li>subgraph_quantity: how many greedy mappings to try</li> <li>mis_sample_quantity: number of samples (if quantum solving is enabled)</li> </ul> In\u00a0[8]: Copied! <pre>config = SolverConfig(method=MethodType.GREEDY, backend=backend_config, greedy=GreedyConfig(default_solving_threshold=20, subgraph_quantity=10))\nsolver = MISSolver(instance, config)\nsolution = solver.solve()[0]\n\nprint(\"Quantum MIS (greedy):\", solution.nodes)\nprint(\"Solution size:\", solution.size)\nprint(\"Independence check: \", is_independent(instance.graph, solution.nodes))\nsolution.draw()\n</pre> config = SolverConfig(method=MethodType.GREEDY, backend=backend_config, greedy=GreedyConfig(default_solving_threshold=20, subgraph_quantity=10)) solver = MISSolver(instance, config) solution = solver.solve()[0]  print(\"Quantum MIS (greedy):\", solution.nodes) print(\"Solution size:\", solution.size) print(\"Independence check: \", is_independent(instance.graph, solution.nodes)) solution.draw() <pre>Quantum MIS (greedy): [0, 3, 7, 9, 11, 14, 23, 24]\nSolution size: 8\nIndependence check:  True\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre> <pre>findfont: Font family 'Century Gothic' not found.\n</pre>"},{"location":"tutorial%202%20-%20Using%20GreedyMIS%20to%20take%20better%20advantage%20of%20Quantum%20Hardware/#tutorial-2-greedymis-example-use-case","title":"Tutorial 2 - GreedyMIS Example Use Case\u00b6","text":"<p>This notebook demonstrates how to solve the Maximum Independent Set (MIS) problem using the GreedyMIS algorithm provided by the <code>MIS</code> library. In this notebook, we present different solving modes:</p> <ul> <li>Classical solver</li> <li>Classical solver with greedy decomposition</li> <li>Quantum solver</li> <li>Quantum solver with greedy decomposition</li> </ul>"},{"location":"tutorial%202%20-%20Using%20GreedyMIS%20to%20take%20better%20advantage%20of%20Quantum%20Hardware/#introduction-to-greedymis","title":"Introduction to GreedyMIS\u00b6","text":"<p>The GreedyMIS algorithm is a heuristic strategy for solving the Maximum Independent Set (MIS) problem by decomposing a graph into smaller subgraphs and solving each part either classically or using a QPU. Results for subgraphs are then aggregated for the final solution in the original graph. This approach is particularly valuable for two reasons:</p> <ul> <li>it supports parallelization, if you have access to several quantum devices or to a single device that can perform several distinct computations concurrently;</li> <li>it can be used to tailor the graph to hardware-constrained systems such as Rydberg atom arrays, where only specific subgraphs (e.g., unit-disk graphs) can be embedded and solved natively.\\n\",</li> </ul> <p>How Subgraphs Are Created: Subgraphs are generated by greedily mapping the original graph onto a physical layout. Starting from different nodes, the algorithm assigns graph nodes to layout positions while preserving adjacency. This produces small, embeddable subgraphs used for solving MIS locally.</p> <p>How Results Are Aggregated: The global MIS is built by combining independent subgraph solutions. After each subgraph MIS is selected, it is added to the global solution, and its nodes and neighbors are removed. The best solution maximizes total size of the global MIS.</p>"},{"location":"tutorial%202%20-%20Using%20GreedyMIS%20to%20take%20better%20advantage%20of%20Quantum%20Hardware/#benefits","title":"Benefits\u00b6","text":"<ul> <li>Decomposes large graphs into smaller, embeddable subgraphs \u2014 especially useful when the full graph is too large to be solved directly on a QPU.</li> <li>While not guaranteed to be optimal, GreedyMIS often yields high-quality solutions faster than exact algorithms.</li> <li>Supports both classical and quantum solvers, allowing hybrid strategies that exploit quantum resources efficiently.</li> <li>Offers control through parameters like <code>default_solving_threshold</code>, <code>subgraph_quantity</code>, and <code>mis_sample_quantity</code> to fine-tune trade-offs between speed and solution quality.</li> </ul>"},{"location":"tutorial%202%20-%20Using%20GreedyMIS%20to%20take%20better%20advantage%20of%20Quantum%20Hardware/#note","title":"Note\u00b6","text":"<p>As of this writing, the package has been tested with unweighted graphs. Adding full-fledged functionality for weighted graphs is in progress.</p>"},{"location":"tutorial%202%20-%20Using%20GreedyMIS%20to%20take%20better%20advantage%20of%20Quantum%20Hardware/#1-classical-solver","title":"1. Classical Solver\u00b6","text":"<p>This method uses a basic classical (eager) solver that attempts to compute the MIS solution directly on the full graph. It works well for small or sparse graphs, but becomes computationally intractable for larger, denser graphs due to the combinatorial complexity of the MIS problem.</p>"},{"location":"tutorial%202%20-%20Using%20GreedyMIS%20to%20take%20better%20advantage%20of%20Quantum%20Hardware/#2-classical-solver-with-greedy-decomposition","title":"2. Classical Solver with Greedy Decomposition\u00b6","text":"<p>In this greedy method, the graph is first decomposed into smaller subgraphs using a greedy mapping strategy. These subgraphs are created by embedding parts of the graph onto a layout (e.g., a layout), enabling efficient and localized solving.</p> <p>The default parameters in GreedyConfig are used to control how the decomposition works. Once the subgraphs are extracted, the MIS is solved separately on each one using the classical solver. The results are then merged recursively to build an overall solution.</p> <p>This approach is especially useful for handling large or complex graphs, where solving the full graph at once is not practical.</p>"},{"location":"tutorial%202%20-%20Using%20GreedyMIS%20to%20take%20better%20advantage%20of%20Quantum%20Hardware/#configuration-parameters","title":"Configuration Parameters\u00b6","text":"<p>For customization of the GreedyMIS algorithm, a <code>GreedyConfig</code> object can be provided to the <code>greedy</code> parameter in <code>SolverConfig</code>.</p> <ul> <li>default_solving_threshold (int): Sets a default size threshold for subgraphs. If a subgraph has fewer nodes than this threshold, it will be solved using an default solver.</li> <li>subgraph_quantity (int): Determines how many different greedy decompositions (mappings) of the original graph should be attempted. More subgraphs can improve solution quality by increasing coverage and diversity, but will increase total computation time.</li> <li>mis_sample_quantity (int): Used in quantum solving mode. Specifies how many samples to draw from the quantum solver per subgraph.</li> </ul>"},{"location":"tutorial%202%20-%20Using%20GreedyMIS%20to%20take%20better%20advantage%20of%20Quantum%20Hardware/#3-quantum-solver","title":"3. Quantum Solver\u00b6","text":"<p>This mode uses a quantum backend (e.g., <code>QutipBackend</code>) to solve the MIS problem directly on the full graph. Quantum solving is suitable for small graphs or subgraphs, where the quantum device can fully embed the problem.</p> <p>Quantum solvers do not return a single deterministic solution \u2014 instead, they return a distribution of possible solutions, each with an associated probability (or frequency). When you call <code>solver.solve()</code>, it returns a list of candidate solutions, typically ordered by frequency. So:</p> <ul> <li><code>result[0]</code> corresponds to the most frequently observed (i.e. most probable) solution from the quantum sampling process.</li> <li>This behavior reflects the inherent probabilistic nature of quantum algorithms, where sampling repeatedly from the solution space allows you to statistically infer the best candidate.</li> </ul> <p>For more details on how the quantum solver works, see the dedicated tutorial here - Using a Quantum Device to solve MIS</p>"},{"location":"tutorial%202%20-%20Using%20GreedyMIS%20to%20take%20better%20advantage%20of%20Quantum%20Hardware/#4-quantum-solver-with-greedy-decomposition","title":"4. Quantum Solver with Greedy Decomposition\u00b6","text":"<p>We combine quantum solving with greedy graph decomposition. Instead of solving the entire graph at once, we:</p> <ul> <li>Break the graph into smaller subgraphs using a greedy layout-based mapping.</li> <li>Solve each subgraph using the quantum backend.</li> <li>Recombine subgraph solutions recursively to form a global solution.</li> <li>Return the final \"best guess\" MIS solution</li> </ul> <p>This allows solving larger graphs by breaking them into quantum-executable pieces.</p> <p>Just like in the basic quantum solver, each subgraph is solved via quantum sampling. And for each subgraph, we get the is the most likely MIS configuration found by the quantum solver. Because each subgraph may produce slightly different outputs on each run (due to quantum randomness), this strategy naturally supports sampling multiple solutions and aggregating them to build diverse, high-quality approximations of the MIS. Thus, <code>result[0]</code> for the greedy solution is the \"best guess\" according to quantum sampling.</p>"},{"location":"tutorial%203%20-%20An%20application%20of%20MIS%20-%20Solving%20the%203SAT%20problem/","title":"Tutorial 3 - 3SAT Solver","text":"In\u00a0[1]: Copied! <pre># imports\nfrom mis import MISSolver, MISInstance, SolverConfig\nfrom mis.shared.types import MISSolution\nimport networkx as nx\nfrom collections import defaultdict\n</pre> # imports from mis import MISSolver, MISInstance, SolverConfig from mis.shared.types import MISSolution import networkx as nx from collections import defaultdict In\u00a0[2]: Copied! <pre>class ThreeSATTerm:\n    \"\"\"\n    A 3SAT term, i.e. a variable (for instance \"x3\") and possibly a negation.\n    \"\"\"\n    variable: str\n    positive: bool\n    \n    def __init__(self, variable : str, positive : bool):\n        self.variable = variable\n        self.positive = positive\n    \n    def eval(self, values: dict[str, bool]) -&gt; bool:\n        \"\"\"\n        Evaluate this term with the value of the variables as specified in `values`.\n        \"\"\"\n        if self.variable not in values:\n            raise ValueError(f\"Variable '{self.variable}' not found in values.\")\n        \n        return values[self.variable] == self.positive\n    \n    \n\nclass ThreeSATClause:\n    \"\"\"\n    A 3SAT clause, i.e. T1 OR T2 OR T3 where T1, T2 and T3 are exactly three 3SAT terms.\n    \"\"\"\n\n    terms: list[ThreeSATTerm]\n    \n    def __init__(self, terms : list[ThreeSATTerm]):\n        if len(terms) != 3:\n            raise ValueError(\"A 3SAT clause must have exactly three terms.\")\n        self.terms = terms\n\n    def eval(self, values: dict[str, bool]) -&gt; bool:\n        \"\"\"\n        Evaluate this clause with the value of the variables as specified in `values`.\n        Returns `True` if and only for any `term`, `term.eval(values)` returns `True`.\n        \"\"\"\n        if len(self.terms) != 3:\n            raise ValueError(\"A 3SAT clause must have exactly three terms.\")\n        for term in self.terms:\n            if term.eval(values):\n                return True\n        return False\n    \n    \n\n\nclass ThreeSATInstance:\n    \"\"\"\n    A 3SAT instance, i.e. C1 AND C2 AND C3  AND Cn where each Ci is a 3SAT Clause.\n    \"\"\"\n\n    clauses: list[ThreeSATClause]\n    _variables: set[str]\n    \n    def __init__(self, clauses : list[ThreeSATClause]):\n        self.clauses = clauses\n        self._variables = set()\n        \n        for clause in self.clauses:\n            for term in clause.terms:\n                self._variables.add(term.variable)\n\n\n    def eval(self, values: dict[str, bool]) -&gt; bool:\n        \"\"\"\n        Evaluate this instance with the value of the variables as specified in `values`.\n\n        Returns `True` if and only for each `clause`, `clause.eval(values)` returns `True`.\n        \"\"\"\n        for clause in self.clauses:\n            if not clause.eval(values):\n                return False\n        return True\n        \n    \n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        The number of clauses in this instance.\n        \"\"\"\n        return len(self.clauses)\n    \n\n    def compile_to_mis(self) -&gt; MISInstance:\n        \"\"\"\n            Compile this instance of 3SAT into an instance of MIS.\n        \"\"\"\n        \n        # A mapping of variable to nodes.\n        #\n        # Keys: `VarName + \"T\"` (for terms that represent a positive variable) / `VarName + \"F\"` (for terms that represent a negative variable).\n        # Values: All the nodes found so far representing this term.\n\n        term_to_nodes : dict[str, list[int]] = defaultdict(lambda : []) # set the default value of a key to an empty list\n        \n        def get_key(term, reverse) : return term.variable + (\"F\" if term.positive ^ reverse else \"T\")\n        \n        \"\"\"\n        If a node representing X is part of the MIS, then X must be true;\n        If a node representing NOT X is part of the MIS, then NOT X must be true;\n        Otherwise, the term does not contribute to the solution (we don't care whether it's true or false).\n        \"\"\"\n        graph = nx.Graph()\n        for i in range(len(self.clauses)):\n            # From all the terms in one clause, it's sufficient that one of them be true.\n            graph.add_edges_from([(3*i,3*i+1), (3*i+1, 3*i+2), (3*i, 3*i+2)])\n            # If X is true, NOT X cannot be true and vice-versa.\n            for j in range(3):\n                for node in term_to_nodes[get_key(self.clauses[i].terms[j], True)]:\n                    graph.add_edge(3*i + j, node)\n            \n            # Add the new nodes to the cache\n            for j in range(3):\n                term_to_nodes[get_key(self.clauses[i].terms[j], False)].append(3*i+j)\n                        \n        return MISInstance(graph)\n            \n    \n\n    def rebuild_result_from_mis(self, solutions: list[MISSolution]) -&gt; dict[str, bool] | None:\n        \"\"\"\n        Search in a list of MISSolution if any of them is a possible solution to 3SAT.\n        \"\"\"\n        if solutions is None:\n            return None\n        \n        for solution in solutions:\n            if len(solution.nodes) != len(self.clauses): \n                continue # skip if the number of nodes isn't enough to be a solution \n            # otherwise, we have a solution\n            result = dict()\n            for variable in self._variables:\n                result[variable] = False # set the default of every variable to False in case the current solution makes them free\n                \n            for node in solution.nodes:\n                term = self.clauses[node//3].terms[node%3] # since each node has index equal to 3*clause + term\n                result[term.variable] = term.positive\n            \n            if not self.eval(result):\n                continue # The MIS provided is not valid, as the quantum algorithm is non-deterministic\n            \n            return result\n                \n        return None\n    \n    \n</pre> class ThreeSATTerm:     \"\"\"     A 3SAT term, i.e. a variable (for instance \"x3\") and possibly a negation.     \"\"\"     variable: str     positive: bool          def __init__(self, variable : str, positive : bool):         self.variable = variable         self.positive = positive          def eval(self, values: dict[str, bool]) -&gt; bool:         \"\"\"         Evaluate this term with the value of the variables as specified in `values`.         \"\"\"         if self.variable not in values:             raise ValueError(f\"Variable '{self.variable}' not found in values.\")                  return values[self.variable] == self.positive            class ThreeSATClause:     \"\"\"     A 3SAT clause, i.e. T1 OR T2 OR T3 where T1, T2 and T3 are exactly three 3SAT terms.     \"\"\"      terms: list[ThreeSATTerm]          def __init__(self, terms : list[ThreeSATTerm]):         if len(terms) != 3:             raise ValueError(\"A 3SAT clause must have exactly three terms.\")         self.terms = terms      def eval(self, values: dict[str, bool]) -&gt; bool:         \"\"\"         Evaluate this clause with the value of the variables as specified in `values`.         Returns `True` if and only for any `term`, `term.eval(values)` returns `True`.         \"\"\"         if len(self.terms) != 3:             raise ValueError(\"A 3SAT clause must have exactly three terms.\")         for term in self.terms:             if term.eval(values):                 return True         return False             class ThreeSATInstance:     \"\"\"     A 3SAT instance, i.e. C1 AND C2 AND C3  AND Cn where each Ci is a 3SAT Clause.     \"\"\"      clauses: list[ThreeSATClause]     _variables: set[str]          def __init__(self, clauses : list[ThreeSATClause]):         self.clauses = clauses         self._variables = set()                  for clause in self.clauses:             for term in clause.terms:                 self._variables.add(term.variable)       def eval(self, values: dict[str, bool]) -&gt; bool:         \"\"\"         Evaluate this instance with the value of the variables as specified in `values`.          Returns `True` if and only for each `clause`, `clause.eval(values)` returns `True`.         \"\"\"         for clause in self.clauses:             if not clause.eval(values):                 return False         return True                    def __len__(self) -&gt; int:         \"\"\"         The number of clauses in this instance.         \"\"\"         return len(self.clauses)           def compile_to_mis(self) -&gt; MISInstance:         \"\"\"             Compile this instance of 3SAT into an instance of MIS.         \"\"\"                  # A mapping of variable to nodes.         #         # Keys: `VarName + \"T\"` (for terms that represent a positive variable) / `VarName + \"F\"` (for terms that represent a negative variable).         # Values: All the nodes found so far representing this term.          term_to_nodes : dict[str, list[int]] = defaultdict(lambda : []) # set the default value of a key to an empty list                  def get_key(term, reverse) : return term.variable + (\"F\" if term.positive ^ reverse else \"T\")                  \"\"\"         If a node representing X is part of the MIS, then X must be true;         If a node representing NOT X is part of the MIS, then NOT X must be true;         Otherwise, the term does not contribute to the solution (we don't care whether it's true or false).         \"\"\"         graph = nx.Graph()         for i in range(len(self.clauses)):             # From all the terms in one clause, it's sufficient that one of them be true.             graph.add_edges_from([(3*i,3*i+1), (3*i+1, 3*i+2), (3*i, 3*i+2)])             # If X is true, NOT X cannot be true and vice-versa.             for j in range(3):                 for node in term_to_nodes[get_key(self.clauses[i].terms[j], True)]:                     graph.add_edge(3*i + j, node)                          # Add the new nodes to the cache             for j in range(3):                 term_to_nodes[get_key(self.clauses[i].terms[j], False)].append(3*i+j)                                  return MISInstance(graph)                        def rebuild_result_from_mis(self, solutions: list[MISSolution]) -&gt; dict[str, bool] | None:         \"\"\"         Search in a list of MISSolution if any of them is a possible solution to 3SAT.         \"\"\"         if solutions is None:             return None                  for solution in solutions:             if len(solution.nodes) != len(self.clauses):                  continue # skip if the number of nodes isn't enough to be a solution              # otherwise, we have a solution             result = dict()             for variable in self._variables:                 result[variable] = False # set the default of every variable to False in case the current solution makes them free                              for node in solution.nodes:                 term = self.clauses[node//3].terms[node%3] # since each node has index equal to 3*clause + term                 result[term.variable] = term.positive                          if not self.eval(result):                 continue # The MIS provided is not valid, as the quantum algorithm is non-deterministic                          return result                          return None           In\u00a0[3]: Copied! <pre># Testing our class\n\nthree_sat_instance_1 = ThreeSATInstance(clauses=[\n   ThreeSATClause([\n      ThreeSATTerm(\"X1\", positive=True),\n      ThreeSATTerm(\"X2\", positive=True),\n      ThreeSATTerm(\"X3\", positive=True),\n   ]),\n   ThreeSATClause([\n      ThreeSATTerm(\"X1\", positive=True),\n      ThreeSATTerm(\"X2\", positive=False),\n      ThreeSATTerm(\"X3\", positive=False),\n   ]),\n])\n</pre>  # Testing our class  three_sat_instance_1 = ThreeSATInstance(clauses=[    ThreeSATClause([       ThreeSATTerm(\"X1\", positive=True),       ThreeSATTerm(\"X2\", positive=True),       ThreeSATTerm(\"X3\", positive=True),    ]),    ThreeSATClause([       ThreeSATTerm(\"X1\", positive=True),       ThreeSATTerm(\"X2\", positive=False),       ThreeSATTerm(\"X3\", positive=False),    ]), ])   <p>Let's explore some possibilities :</p> In\u00a0[4]: Copied! <pre>print(three_sat_instance_1.eval({'X1': True, 'X2': True, 'X3': True})) # True \nprint(three_sat_instance_1.eval({'X1': False, 'X2': False, 'X3': False})) # False\nprint(three_sat_instance_1.eval({'X1': True, 'X2': False, 'X3': False})) # True\nprint(three_sat_instance_1.eval({'X1': False, 'X2': True, 'X3': True})) # False\n</pre> print(three_sat_instance_1.eval({'X1': True, 'X2': True, 'X3': True})) # True  print(three_sat_instance_1.eval({'X1': False, 'X2': False, 'X3': False})) # False print(three_sat_instance_1.eval({'X1': True, 'X2': False, 'X3': False})) # True print(three_sat_instance_1.eval({'X1': False, 'X2': True, 'X3': True})) # False <pre>True\nFalse\nTrue\nFalse\n</pre> <p>Time to try our solver :</p> In\u00a0[5]: Copied! <pre>config = SolverConfig()\n\n# Create the MIS instance\ninstance = three_sat_instance_1.compile_to_mis()\n\n# Run the solver\nsolver = MISSolver(instance, config)\nsolutions = solver.solve()\nresult = three_sat_instance_1.rebuild_result_from_mis(solutions)\n\nif result is None:\n   print(\"No solution exists\")\nelse: \n   print(\"Possible solution : \", result)\n   print(three_sat_instance_1.eval(result)) # Should output True\n</pre> config = SolverConfig()  # Create the MIS instance instance = three_sat_instance_1.compile_to_mis()  # Run the solver solver = MISSolver(instance, config) solutions = solver.solve() result = three_sat_instance_1.rebuild_result_from_mis(solutions)  if result is None:    print(\"No solution exists\") else:     print(\"Possible solution : \", result)    print(three_sat_instance_1.eval(result)) # Should output True <pre>Possible solution :  {'X1': True, 'X2': False, 'X3': False}\nTrue\n</pre> <p>Remark : Many solutions are actually possible, our algorithm takes the first suitable one it explored</p> In\u00a0[6]: Copied! <pre>three_sat_instance_2 = ThreeSATInstance(clauses=[\n    ThreeSATClause([\n        ThreeSATTerm(\"X1\", positive=True),\n        ThreeSATTerm(\"X2\", positive=False),\n        ThreeSATTerm(\"X1\", positive=True),\n    ]),\n    ThreeSATClause([\n        ThreeSATTerm(\"X1\", positive=False),\n        ThreeSATTerm(\"X1\", positive=False),\n        ThreeSATTerm(\"X2\", positive=False),\n    ]),\n    ThreeSATClause([\n        ThreeSATTerm(\"X2\", positive=True),\n        ThreeSATTerm(\"X2\", positive=True),\n        ThreeSATTerm(\"X2\", positive=True),\n    ]),\n])\n\nconfig = SolverConfig()\n\n# Create the MIS instance\ninstance = three_sat_instance_2.compile_to_mis()\n\n# Run the solver\nsolver = MISSolver(instance, config)\nsolutions = solver.solve()\nresult = three_sat_instance_2.rebuild_result_from_mis(solutions)\n\nif result is None:\n   print(\"No solution exists\") \nelse: \n   print(\"Possible solution : \", result)\n   print(three_sat_instance_2.eval(result))\n# Should output \"No Solution exists\"\n</pre> three_sat_instance_2 = ThreeSATInstance(clauses=[     ThreeSATClause([         ThreeSATTerm(\"X1\", positive=True),         ThreeSATTerm(\"X2\", positive=False),         ThreeSATTerm(\"X1\", positive=True),     ]),     ThreeSATClause([         ThreeSATTerm(\"X1\", positive=False),         ThreeSATTerm(\"X1\", positive=False),         ThreeSATTerm(\"X2\", positive=False),     ]),     ThreeSATClause([         ThreeSATTerm(\"X2\", positive=True),         ThreeSATTerm(\"X2\", positive=True),         ThreeSATTerm(\"X2\", positive=True),     ]), ])  config = SolverConfig()  # Create the MIS instance instance = three_sat_instance_2.compile_to_mis()  # Run the solver solver = MISSolver(instance, config) solutions = solver.solve() result = three_sat_instance_2.rebuild_result_from_mis(solutions)  if result is None:    print(\"No solution exists\")  else:     print(\"Possible solution : \", result)    print(three_sat_instance_2.eval(result)) # Should output \"No Solution exists\" <pre>No solution exists\n</pre> In\u00a0[7]: Copied! <pre>three_sat_instance_3 = ThreeSATInstance(clauses=[\n    ThreeSATClause([\n        ThreeSATTerm(\"X1\", positive=True),\n        ThreeSATTerm(\"X2\", positive=False),\n        ThreeSATTerm(\"X3\", positive=True),\n    ]),\n    ThreeSATClause([\n        ThreeSATTerm(\"X1\", positive=False),\n        ThreeSATTerm(\"X2\", positive=True),\n        ThreeSATTerm(\"X3\", positive=False),\n    ]),\n    ThreeSATClause([\n        ThreeSATTerm(\"X2\", positive=True),\n        ThreeSATTerm(\"X3\", positive=True),\n        ThreeSATTerm(\"X4\", positive=True),\n    ]),\n    ThreeSATClause([\n        ThreeSATTerm(\"X2\", positive=False),\n        ThreeSATTerm(\"X3\", positive=False),\n        ThreeSATTerm(\"X4\", positive=False),\n    ]),\n    ThreeSATClause([\n        ThreeSATTerm(\"X1\", positive=True),\n        ThreeSATTerm(\"X4\", positive=True),\n        ThreeSATTerm(\"X3\", positive=False),\n    ]),\n])\n\n\nconfig = SolverConfig()\n\n# Create the MIS instance\ninstance = three_sat_instance_3.compile_to_mis()\n\n# Run the solver\nsolver = MISSolver(instance, config)\nsolutions = solver.solve()\nresult = three_sat_instance_3.rebuild_result_from_mis(solutions)\n\nif result is None:\n   print(\"No solution exists\") \nelse: \n   print(\"Possible solution : \", result)\n   print(three_sat_instance_3.eval(result))\n</pre> three_sat_instance_3 = ThreeSATInstance(clauses=[     ThreeSATClause([         ThreeSATTerm(\"X1\", positive=True),         ThreeSATTerm(\"X2\", positive=False),         ThreeSATTerm(\"X3\", positive=True),     ]),     ThreeSATClause([         ThreeSATTerm(\"X1\", positive=False),         ThreeSATTerm(\"X2\", positive=True),         ThreeSATTerm(\"X3\", positive=False),     ]),     ThreeSATClause([         ThreeSATTerm(\"X2\", positive=True),         ThreeSATTerm(\"X3\", positive=True),         ThreeSATTerm(\"X4\", positive=True),     ]),     ThreeSATClause([         ThreeSATTerm(\"X2\", positive=False),         ThreeSATTerm(\"X3\", positive=False),         ThreeSATTerm(\"X4\", positive=False),     ]),     ThreeSATClause([         ThreeSATTerm(\"X1\", positive=True),         ThreeSATTerm(\"X4\", positive=True),         ThreeSATTerm(\"X3\", positive=False),     ]), ])   config = SolverConfig()  # Create the MIS instance instance = three_sat_instance_3.compile_to_mis()  # Run the solver solver = MISSolver(instance, config) solutions = solver.solve() result = three_sat_instance_3.rebuild_result_from_mis(solutions)  if result is None:    print(\"No solution exists\")  else:     print(\"Possible solution : \", result)    print(three_sat_instance_3.eval(result))  <pre>Possible solution :  {'X1': False, 'X2': False, 'X3': True, 'X4': True}\nTrue\n</pre>"},{"location":"tutorial%203%20-%20An%20application%20of%20MIS%20-%20Solving%20the%203SAT%20problem/#tutorial-3-3sat-solver","title":"Tutorial 3 - 3SAT Solver\u00b6","text":"<p>The Boolean Satisfiability Problem (or SAT) is a problem in logics and computer science of finding solutions to logical equations. For instance, if we know that two properties $A$ and $B$ are bound by $A \\Rightarrow B$ and $A \\Rightarrow not\\ B$, we can deduce that $A$ must be false.</p> <p>The SAT problem, and its variants, appear commonly in optimization algorithms, software verification, electronics circuit generation and validation, artificial intelligence, etc.</p> <p>The SAT problem has been demonstrated to be NP-complete. As of this writing, there is no exact solver that can generally solve the SAT problem (or its simpler sibling 3SAT) in polynomial time. In this notebook, we will demonstrate how we can resolve a restricted version of SAT named 3SAT, using MIS. The ideas exposed here can easily be expanded into a general SAT solver, as well as solvers for entirely different classes of problems.</p>"},{"location":"tutorial%203%20-%20An%20application%20of%20MIS%20-%20Solving%20the%203SAT%20problem/#representing-our-3sat-instance","title":"Representing our 3SAT instance\u00b6","text":"<p>In 3SAT, we restrict ourselves to formulas that look like $$(A \\vee B \\vee \\neg C) \\wedge (D \\vee C \\vee E) \\wedge ...$$</p> <p>In other words an instance of 3SAT is a conjonction (\"ands\") of clauses, where each clauses is a disjunctions (\"ors\") of terms, where each term is either a variable or a negated variable. We further restrict that the same variable may not appear more than once in one clause (it may, of course, appear more than once in an instance).</p> <p>From this, we want to convert our instance of 3SAT into an instance of MIS.</p> <p>The general idea is that:</p> <ul> <li><p>We want to convert an instance of 3SAT into a graph in which if a node is part of a MIS solution, it MUST be true (note that a node that is not part of a MIS solution may or may not be true, we don't care, as it does not contribute to the result) every term is compiled into a node in our graph</p> </li> <li><p>Since X and NOT X cannot be both true simultaneously, if there is a term X and a term NOT X, we connect their representations in our graph, to make sure that both of them cannot appear simultaneously in a solution to MIS</p> </li> <li><p>In every clause, we connect the three nodes in the graph, to make sure that only one of them MUST be true (This bounds the maximum number of nodes to the number of clauses)</p> </li> <li><p>Once we have a MIS solution, we only need to confirm that one node in each clause is part of the MIS solution, i.e. we only need to check the length of the MIS solution (Since the maximum number of nodes is the number of clauses, and that in each triangle representing a clause we can have at most one node, reaching a configuration with exactly the good number of nodes implies that the solution is valid).</p> </li> </ul>"},{"location":"tutorial%203%20-%20An%20application%20of%20MIS%20-%20Solving%20the%203SAT%20problem/#testing-our-class","title":"Testing our class\u00b6","text":""},{"location":"tutorial%203%20-%20An%20application%20of%20MIS%20-%20Solving%20the%203SAT%20problem/#example-1","title":"Example 1\u00b6","text":"<p>$(X_1 \\text{ OR } X_2 \\text{ OR } X_3) \\text{ AND }(X_1 \\text{ OR } \\overline X_2 \\text{ OR } \\overline X_3)$</p> <p>Initializing our instance :</p>"},{"location":"tutorial%203%20-%20An%20application%20of%20MIS%20-%20Solving%20the%203SAT%20problem/#example-2","title":"Example 2 :\u00b6","text":"<p>$(X_1 \\text{ OR } \\overline X_2 \\text{ OR } X_1) \\text{ AND } (\\overline X_1 \\text{ OR } \\overline X_1 \\text{ OR } \\overline X_2) \\text{ AND } ( X_2 \\text{ OR } X_2 \\text{ OR } X_2)$</p> <p>This one actually doesn't have a solution as we will see :</p>"},{"location":"tutorial%203%20-%20An%20application%20of%20MIS%20-%20Solving%20the%203SAT%20problem/#example-3","title":"Example 3 :\u00b6","text":"<p>$(X_1 \\text{ OR } \\overline X_2 \\text{ OR } X_3) \\text{ AND } (\\overline X_1 \\text{ OR } X_2 \\text{ OR } \\overline X_3) \\text{ AND } (X_2 \\text{ OR } X_3 \\text{ OR } X_4) \\text{ AND } (\\overline X_2 \\text{ OR } \\overline X_3 \\text{ OR } \\overline X_4) \\text{ AND } (X_1 \\text{ OR } X_4 \\text{ OR } \\overline X_3)$</p>"},{"location":"tutorial%204%20-%20An%20application%20of%20MIS%20-%20Solving%20a%20Graph%20Coloring%20problem/","title":"Tutorial 4 - Graph Coloring Solver","text":"In\u00a0[1]: Copied! <pre># imports\nfrom mis.coloring import GraphColoringSolver\nfrom mis.data import DataLoader\nfrom pathlib import Path\nfrom mis.pipeline.config import SolverConfig\nfrom mis.shared.types import MethodType\n</pre> # imports from mis.coloring import GraphColoringSolver from mis.data import DataLoader from pathlib import Path from mis.pipeline.config import SolverConfig from mis.shared.types import MethodType In\u00a0[2]: Copied! <pre>loader = DataLoader()\nloader.load_from_csv_coordinates(Path('./datasets/coloring/antenna_Paris.csv'))\n</pre> loader = DataLoader() loader.load_from_csv_coordinates(Path('./datasets/coloring/antenna_Paris.csv')) <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[2], line 2\n      1 loader = DataLoader()\n----&gt; 2 loader.load_from_csv_coordinates(Path('./datasets/coloring/antenna_Paris.csv'))\n\nFile ~/work/maximum-independent-set/maximum-independent-set/mis/data/dataloader.py:45, in DataLoader.load_from_csv_coordinates(self, file_path)\n     43 # error handling with a try-except block\n     44 if not file_path.exists():\n---&gt; 45     raise FileNotFoundError(f\"The file {file_path} does not exist.\")\n     46 if not file_path.is_file():\n     47     raise ValueError(f\"The path {file_path} is not a file.\")\n\nFileNotFoundError: The file datasets/coloring/antenna_Paris.csv does not exist.</pre> In\u00a0[3]: Copied! <pre>instance = loader.build_mis_instance_from_coordinates(antenna_range=1.2)\n</pre> instance = loader.build_mis_instance_from_coordinates(antenna_range=1.2) <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 instance = loader.build_mis_instance_from_coordinates(antenna_range=1.2)\n\nFile ~/work/maximum-independent-set/maximum-independent-set/mis/data/dataloader.py:82, in DataLoader.build_mis_instance_from_coordinates(self, antenna_range, antennas)\n     68 def build_mis_instance_from_coordinates(\n     69     self, antenna_range: float, antennas: set[int] = None\n     70 ) -&gt; MISInstance:\n     71     \"\"\"\n     72     Build a Maximum Independent Set (MIS) instance from the loaded coordinates.\n     73     The function creates a graph where nodes represent antennas and edges represent\n   (...)\n     80         MISInstance: An instance of the Maximum Independent Set problem represented as a graph.\n     81     \"\"\"\n---&gt; 82     if self.coordinates_dataset is None:\n     83         raise ValueError(\n     84             \"Coordinates dataset is not loaded. Please load the dataset using load_from_csv_coordinates method.\"\n     85         )\n     87     if antennas is None:\n\nAttributeError: 'DataLoader' object has no attribute 'coordinates_dataset'</pre> <p>Let's visualize our dataset :</p> In\u00a0[4]: Copied! <pre>instance.draw()\n</pre> instance.draw() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 instance.draw()\n\nNameError: name 'instance' is not defined</pre> In\u00a0[5]: Copied! <pre>from mis.pipeline.kernelization import Kernelization\n\n\nsolver = GraphColoringSolver(loader, 1.2, SolverConfig(\n    method = MethodType.EAGER,\n    max_iterations=1,\n))\nsolver.solve()\nsolver.visualize_solution()\nprint(solver.colors)   \nprint(f\"Number of colors used: {solver.colors_count}\")\n</pre> from mis.pipeline.kernelization import Kernelization   solver = GraphColoringSolver(loader, 1.2, SolverConfig(     method = MethodType.EAGER,     max_iterations=1, )) solver.solve() solver.visualize_solution() print(solver.colors)    print(f\"Number of colors used: {solver.colors_count}\") <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[5], line 8\n      1 from mis.pipeline.kernelization import Kernelization\n      4 solver = GraphColoringSolver(loader, 1.2, SolverConfig(\n      5     method = MethodType.EAGER,\n      6     max_iterations=1,\n      7 ))\n----&gt; 8 solver.solve()\n      9 solver.visualize_solution()\n     10 print(solver.colors)   \n\nFile ~/work/maximum-independent-set/maximum-independent-set/mis/coloring/coloring.py:65, in GraphColoringSolver.solve(self, antennas, is_second_coloring)\n     51 \"\"\"\n     52 Solve the graph coloring problem by finding a maximum independent set\n     53 for the given antenna range and coloring the antennas accordingly.\n   (...)\n     62     Execution[list[MISSolution]]: An execution object containing the nodes of each color in the solution.\n     63 \"\"\"\n     64 if antennas is None:\n---&gt; 65     antennas = set([x for x in range(len(self.loader.coordinates_dataset))])\n     67 res = []\n     68 if not is_second_coloring:\n\nAttributeError: 'DataLoader' object has no attribute 'coordinates_dataset'</pre> <p>The array <code>solver.colors</code> represents the group assigned to each antenna by the algorithm, such that all the antennas of the same group can share the same frequency without interfering with each other.</p> In\u00a0[6]: Copied! <pre>from mis.pipeline.maximization import Maximization\nfrom mis import BackendConfig, BackendType\n\nbackend_config = BackendConfig(\n    backend = BackendType.QUTIP\n)\n\nsolver = GraphColoringSolver(loader, 1.2, SolverConfig(\n    method = MethodType.EAGER,\n    backend = backend_config,\n    max_iterations=1\n))\nsolver.solve()\nsolver.visualize_solution()\nprint(solver.colors)   \nprint(f\"Number of colors used: {solver.colors_count}\")\n</pre> from mis.pipeline.maximization import Maximization from mis import BackendConfig, BackendType  backend_config = BackendConfig(     backend = BackendType.QUTIP )  solver = GraphColoringSolver(loader, 1.2, SolverConfig(     method = MethodType.EAGER,     backend = backend_config,     max_iterations=1 )) solver.solve() solver.visualize_solution() print(solver.colors)    print(f\"Number of colors used: {solver.colors_count}\") <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[6], line 13\n      4 backend_config = BackendConfig(\n      5     backend = BackendType.QUTIP\n      6 )\n      8 solver = GraphColoringSolver(loader, 1.2, SolverConfig(\n      9     method = MethodType.EAGER,\n     10     backend = backend_config,\n     11     max_iterations=1\n     12 ))\n---&gt; 13 solver.solve()\n     14 solver.visualize_solution()\n     15 print(solver.colors)   \n\nFile ~/work/maximum-independent-set/maximum-independent-set/mis/coloring/coloring.py:65, in GraphColoringSolver.solve(self, antennas, is_second_coloring)\n     51 \"\"\"\n     52 Solve the graph coloring problem by finding a maximum independent set\n     53 for the given antenna range and coloring the antennas accordingly.\n   (...)\n     62     Execution[list[MISSolution]]: An execution object containing the nodes of each color in the solution.\n     63 \"\"\"\n     64 if antennas is None:\n---&gt; 65     antennas = set([x for x in range(len(self.loader.coordinates_dataset))])\n     67 res = []\n     68 if not is_second_coloring:\n\nAttributeError: 'DataLoader' object has no attribute 'coordinates_dataset'</pre> In\u00a0[7]: Copied! <pre>solver = GraphColoringSolver(loader, 1.2, SolverConfig(\n    method = MethodType.EAGER,\n    backend = backend_config,\n    max_iterations = 1,\n    preprocessor = lambda graph: Kernelization(graph),\n    postprocessor = lambda : Maximization()\n))\nsolver.solve()\nsolver.visualize_solution()\nprint(solver.colors)   \nprint(f\"Number of colors used: {solver.colors_count}\")\n</pre>   solver = GraphColoringSolver(loader, 1.2, SolverConfig(     method = MethodType.EAGER,     backend = backend_config,     max_iterations = 1,     preprocessor = lambda graph: Kernelization(graph),     postprocessor = lambda : Maximization() )) solver.solve() solver.visualize_solution() print(solver.colors)    print(f\"Number of colors used: {solver.colors_count}\") <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[7], line 8\n      1 solver = GraphColoringSolver(loader, 1.2, SolverConfig(\n      2     method = MethodType.EAGER,\n      3     backend = backend_config,\n   (...)\n      6     postprocessor = lambda : Maximization()\n      7 ))\n----&gt; 8 solver.solve()\n      9 solver.visualize_solution()\n     10 print(solver.colors)   \n\nFile ~/work/maximum-independent-set/maximum-independent-set/mis/coloring/coloring.py:65, in GraphColoringSolver.solve(self, antennas, is_second_coloring)\n     51 \"\"\"\n     52 Solve the graph coloring problem by finding a maximum independent set\n     53 for the given antenna range and coloring the antennas accordingly.\n   (...)\n     62     Execution[list[MISSolution]]: An execution object containing the nodes of each color in the solution.\n     63 \"\"\"\n     64 if antennas is None:\n---&gt; 65     antennas = set([x for x in range(len(self.loader.coordinates_dataset))])\n     67 res = []\n     68 if not is_second_coloring:\n\nAttributeError: 'DataLoader' object has no attribute 'coordinates_dataset'</pre> In\u00a0[8]: Copied! <pre>loader_2 = DataLoader()\nloader_2.load_from_csv_coordinates(Path('./datasets/coloring/counterexample_1.csv'))\ninstance = loader_2.build_mis_instance_from_coordinates(antenna_range=112)\ninstance.draw()\n</pre> loader_2 = DataLoader() loader_2.load_from_csv_coordinates(Path('./datasets/coloring/counterexample_1.csv')) instance = loader_2.build_mis_instance_from_coordinates(antenna_range=112) instance.draw() <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[8], line 2\n      1 loader_2 = DataLoader()\n----&gt; 2 loader_2.load_from_csv_coordinates(Path('./datasets/coloring/counterexample_1.csv'))\n      3 instance = loader_2.build_mis_instance_from_coordinates(antenna_range=112)\n      4 instance.draw()\n\nFile ~/work/maximum-independent-set/maximum-independent-set/mis/data/dataloader.py:45, in DataLoader.load_from_csv_coordinates(self, file_path)\n     43 # error handling with a try-except block\n     44 if not file_path.exists():\n---&gt; 45     raise FileNotFoundError(f\"The file {file_path} does not exist.\")\n     46 if not file_path.is_file():\n     47     raise ValueError(f\"The path {file_path} is not a file.\")\n\nFileNotFoundError: The file datasets/coloring/counterexample_1.csv does not exist.</pre> In\u00a0[9]: Copied! <pre>solver_2 = GraphColoringSolver(loader_2, 112, SolverConfig(\n    method = MethodType.EAGER,\n    max_iterations=1\n))\nsolver_2.solve()\nsolver_2.visualize_solution()\nprint(solver_2.colors)   \nprint(f\"Number of colors used: {solver_2.colors_count}\")\n</pre> solver_2 = GraphColoringSolver(loader_2, 112, SolverConfig(     method = MethodType.EAGER,     max_iterations=1 )) solver_2.solve() solver_2.visualize_solution() print(solver_2.colors)    print(f\"Number of colors used: {solver_2.colors_count}\") <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[9], line 5\n      1 solver_2 = GraphColoringSolver(loader_2, 112, SolverConfig(\n      2     method = MethodType.EAGER,\n      3     max_iterations=1\n      4 ))\n----&gt; 5 solver_2.solve()\n      6 solver_2.visualize_solution()\n      7 print(solver_2.colors)   \n\nFile ~/work/maximum-independent-set/maximum-independent-set/mis/coloring/coloring.py:65, in GraphColoringSolver.solve(self, antennas, is_second_coloring)\n     51 \"\"\"\n     52 Solve the graph coloring problem by finding a maximum independent set\n     53 for the given antenna range and coloring the antennas accordingly.\n   (...)\n     62     Execution[list[MISSolution]]: An execution object containing the nodes of each color in the solution.\n     63 \"\"\"\n     64 if antennas is None:\n---&gt; 65     antennas = set([x for x in range(len(self.loader.coordinates_dataset))])\n     67 res = []\n     68 if not is_second_coloring:\n\nAttributeError: 'DataLoader' object has no attribute 'coordinates_dataset'</pre> <p>Actually, the previous graph is bipartite as it has no odd cycles, hence allowing a coloring with only two colors. It follows that our previous coloring is not optimal. We can actually improve the result of the solver using some post-processing, which involves trying to recolor every antenna of some color with an already existing colors, and if succesful, will reduce the numeber of colors.</p> In\u00a0[10]: Copied! <pre>solver_2.reduce_colors()\nsolver_2.visualize_solution()\nprint(solver_2.colors)   \nprint(f\"Number of colors used: {solver_2.colors_count}\")\n</pre> solver_2.reduce_colors() solver_2.visualize_solution() print(solver_2.colors)    print(f\"Number of colors used: {solver_2.colors_count}\") <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 solver_2.reduce_colors()\n      2 solver_2.visualize_solution()\n      3 print(solver_2.colors)   \n\nFile ~/work/maximum-independent-set/maximum-independent-set/mis/coloring/coloring.py:118, in GraphColoringSolver.reduce_colors(self)\n    111 def reduce_colors(self) -&gt; list[int]:\n    112     \"\"\"\n    113     Attempts to reduce the number of colors used in the solution\n    114     by trying to reassign every node of some color.\n    115     Returns :\n    116         list[int]: A list of colors for each antenna, where the index represents the antenna.\n    117     \"\"\"\n--&gt; 118     antennas = set([x for x in range(len(self.loader.coordinates_dataset))])\n    119     graph = self.loader.build_mis_instance_from_coordinates(self.antenna_range, antennas).graph\n    120     new_colors = deepcopy(self.colors)\n\nAttributeError: 'DataLoader' object has no attribute 'coordinates_dataset'</pre> <p>It seems that this approach successfully worked in this case, what about our original dataset ?</p> In\u00a0[11]: Copied! <pre>solver.reduce_colors()\nsolver.visualize_solution()\nprint(solver.colors)   \nprint(f\"Number of colors used: {solver.colors_count}\")\n</pre> solver.reduce_colors() solver.visualize_solution() print(solver.colors)    print(f\"Number of colors used: {solver.colors_count}\") <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[11], line 1\n----&gt; 1 solver.reduce_colors()\n      2 solver.visualize_solution()\n      3 print(solver.colors)   \n\nFile ~/work/maximum-independent-set/maximum-independent-set/mis/coloring/coloring.py:118, in GraphColoringSolver.reduce_colors(self)\n    111 def reduce_colors(self) -&gt; list[int]:\n    112     \"\"\"\n    113     Attempts to reduce the number of colors used in the solution\n    114     by trying to reassign every node of some color.\n    115     Returns :\n    116         list[int]: A list of colors for each antenna, where the index represents the antenna.\n    117     \"\"\"\n--&gt; 118     antennas = set([x for x in range(len(self.loader.coordinates_dataset))])\n    119     graph = self.loader.build_mis_instance_from_coordinates(self.antenna_range, antennas).graph\n    120     new_colors = deepcopy(self.colors)\n\nAttributeError: 'DataLoader' object has no attribute 'coordinates_dataset'</pre> <p>We can see that it worked, reducing indeed the total number of colors to 8.</p> In\u00a0[12]: Copied! <pre>solver_3 = GraphColoringSolver(loader, 1.2, SolverConfig(\n    method = MethodType.EAGER,\n    max_iterations=1\n))\nsets = solver_3.split_antennas_by_degree(2) # setting the threshold to 2\nsolver_3.solve(antennas=sets[0])\nsolver_3.solve(antennas=sets[1], is_second_coloring=True)\nsolver_3.reduce_colors()\nsolver_3.visualize_solution()\nprint(solver_3.colors)   \nprint(f\"Number of colors used: {solver_3.colors_count}\")\nprint(solver_3.check_solution())\n</pre> solver_3 = GraphColoringSolver(loader, 1.2, SolverConfig(     method = MethodType.EAGER,     max_iterations=1 )) sets = solver_3.split_antennas_by_degree(2) # setting the threshold to 2 solver_3.solve(antennas=sets[0]) solver_3.solve(antennas=sets[1], is_second_coloring=True) solver_3.reduce_colors() solver_3.visualize_solution() print(solver_3.colors)    print(f\"Number of colors used: {solver_3.colors_count}\") print(solver_3.check_solution()) <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[12], line 5\n      1 solver_3 = GraphColoringSolver(loader, 1.2, SolverConfig(\n      2     method = MethodType.EAGER,\n      3     max_iterations=1\n      4 ))\n----&gt; 5 sets = solver_3.split_antennas_by_degree(2) # setting the threshold to 2\n      6 solver_3.solve(antennas=sets[0])\n      7 solver_3.solve(antennas=sets[1], is_second_coloring=True)\n\nFile ~/work/maximum-independent-set/maximum-independent-set/mis/coloring/coloring.py:99, in GraphColoringSolver.split_antennas_by_degree(self, threshold)\n     87 def split_antennas_by_degree(self, threshold: int) -&gt; list[set[int]]:\n     88     \"\"\"\n     89     Splits the antennas into two sets based on a threshold of the degree of the node.\n     90     Antennas with a degree less than or equal to the threshold will be grouped together.\n   (...)\n     97         less than or equal to the threshold, and the second set contains the rest.\n     98     \"\"\"\n---&gt; 99     graph = self.loader.build_mis_instance_from_coordinates(self.antenna_range).graph\n    100     low_degree_antennas = set()\n    101     high_degree_antennas = set()\n\nFile ~/work/maximum-independent-set/maximum-independent-set/mis/data/dataloader.py:82, in DataLoader.build_mis_instance_from_coordinates(self, antenna_range, antennas)\n     68 def build_mis_instance_from_coordinates(\n     69     self, antenna_range: float, antennas: set[int] = None\n     70 ) -&gt; MISInstance:\n     71     \"\"\"\n     72     Build a Maximum Independent Set (MIS) instance from the loaded coordinates.\n     73     The function creates a graph where nodes represent antennas and edges represent\n   (...)\n     80         MISInstance: An instance of the Maximum Independent Set problem represented as a graph.\n     81     \"\"\"\n---&gt; 82     if self.coordinates_dataset is None:\n     83         raise ValueError(\n     84             \"Coordinates dataset is not loaded. Please load the dataset using load_from_csv_coordinates method.\"\n     85         )\n     87     if antennas is None:\n\nAttributeError: 'DataLoader' object has no attribute 'coordinates_dataset'</pre>"},{"location":"tutorial%204%20-%20An%20application%20of%20MIS%20-%20Solving%20a%20Graph%20Coloring%20problem/#tutorial-4-graph-coloring-solver","title":"Tutorial 4 - Graph Coloring Solver\u00b6","text":"<p>In this notebook, we are going to implement a graph coloring algorithm based on a MIS solver for a practical problem of sharing a bandwidth of frequencies for a network of antennas.</p>"},{"location":"tutorial%204%20-%20An%20application%20of%20MIS%20-%20Solving%20a%20Graph%20Coloring%20problem/#importing-our-dataset","title":"Importing our dataset\u00b6","text":"<p>The practical dataset of interest is the placement of 5G antennas in Paris that can be found in the <code>antenna_Paris.csv</code> file. A set of antennas are distributed over the city with a specific coverage range. Therefore, some antennas will be in range of each other and cannot share the same frequency.</p>"},{"location":"tutorial%204%20-%20An%20application%20of%20MIS%20-%20Solving%20a%20Graph%20Coloring%20problem/#representing-our-problem-instance","title":"Representing our problem instance\u00b6","text":"<p>The first step is to represent the problem by a graph. In this case, each node represents an antenna, with an edge between two if they are in the range of each other. For the sake of simplicity, we will reduce the graph size by considering only antennas within a constant range R, set to 1.2 km.</p>"},{"location":"tutorial%204%20-%20An%20application%20of%20MIS%20-%20Solving%20a%20Graph%20Coloring%20problem/#solving-the-graph-coloring-problem","title":"Solving the Graph Coloring Problem\u00b6","text":"<p>We will use the greedy heuristic algorithm described in Appendix A to find a coloring of the graph using MIS output.</p> <p>The algorithm starts with a set $S$ of all the nodes in the graph, and at each iteration it searches for a maximum independent set of nodes of the subgraph formed by the nodes currently in $S$, colors all of the nodes of the MIS in the same color, then removes them from $S$. The operation is repeated until $S$ is empty.</p>"},{"location":"tutorial%204%20-%20An%20application%20of%20MIS%20-%20Solving%20a%20Graph%20Coloring%20problem/#using-a-classical-solver","title":"Using a classical solver\u00b6","text":"<p>We will first solve the coloring problem using the standard classical and heuristic MIS solver in Networkx. As it is heuristic and non-deterministic, this solver does not guarantee an optimal solution.</p>"},{"location":"tutorial%204%20-%20An%20application%20of%20MIS%20-%20Solving%20a%20Graph%20Coloring%20problem/#using-the-quantum-sdk-qutip","title":"Using the quantum SDK QuTiP\u00b6","text":"<p>We will now use a quantum solver to solve the MIS instances used by our coloring algorithm, please refer to tutorial 1a for more details about the solver.</p>"},{"location":"tutorial%204%20-%20An%20application%20of%20MIS%20-%20Solving%20a%20Graph%20Coloring%20problem/#applying-pre-and-post-processors","title":"Applying Pre and Post Processors\u00b6","text":"<p>Performs optimizations before and after running the Quantum solver in order to enhance the quality of the results given by the algorithm.</p>"},{"location":"tutorial%204%20-%20An%20application%20of%20MIS%20-%20Solving%20a%20Graph%20Coloring%20problem/#enhancing-our-algorithm","title":"Enhancing our algorithm\u00b6","text":"<p>We now explore further improvements to the MIS-based coloring algorithm.</p>"},{"location":"tutorial%204%20-%20An%20application%20of%20MIS%20-%20Solving%20a%20Graph%20Coloring%20problem/#color-reduction","title":"Color Reduction\u00b6","text":"<p>Note that the approach we are using is a greedy heuristic algorithm, that does not necessarily give the optimal solution, let's look at an example where it is more obvious.</p>"},{"location":"tutorial%204%20-%20An%20application%20of%20MIS%20-%20Solving%20a%20Graph%20Coloring%20problem/#node-degree-segmentation","title":"Node Degree Segmentation\u00b6","text":"<p>Let's try to improve more the algorithm, by preprocessing the graph. We first split the antennas into two groups, those with many antennas in the their range, and those with less. More formally, we will after fixing a threshold, split the nodes of the graph those with a degree higher than the threshold, and the others, then solve the coloring problem on each set, and finally join the results with the <code>reduce_colors</code> method.</p>"},{"location":"usage/","title":"Usage","text":"<pre><code>from mis import MISSolver, MISInstance, BackendConfig, SolverConfig\nimport networkx as nx\n\n# Generate a simple graph (here, a triangle)\ngraph = nx.Graph()\ngraph.add_edges_from([(0, 1), (0, 2)])\ninstance = MISInstance(graph)\n\n# Use a default quantum backend.\nconfig = SolverConfig(backend=BackendConfig())\nsolver = MISSolver(instance, config)\n\n# Solve the MIS problem.\nresults = solver.solve()\n\n# Show the results.\nprint(\"MIS solutions:\", results)\nresults[0].draw()\n</code></pre>"},{"location":"contributing/first%20contact/","title":"First contact","text":""},{"location":"contributing/first%20contact/#getting-the-code","title":"Getting the code","text":"<p>The code is available on GitHub.</p> <p>To clone it</p> <pre><code>$ git clone git@github.com:pasqal-io/maximum-independent-set.git\n</code></pre> <p>or</p> <pre><code>$ git clone https://github.com/pasqal-io/maximum-independent-set.git\n</code></pre>"},{"location":"contributing/first%20contact/#hatch-instructions","title":"Hatch instructions","text":"<p>We use <code>hatch</code> and Python 3.10 for development.</p>"},{"location":"contributing/first%20contact/#setting-up","title":"Setting up","text":"<p>With Python and pip installed, to setup the environment:</p> <pre><code>$ pip install hatch\n$ hatch -v shell\n</code></pre> <p>This will open a shell with all the dependencies installed.</p>"},{"location":"contributing/first%20contact/#running-tests","title":"Running tests","text":"<p>To run the unit and integration tests</p> <pre><code>$ hatch run test\n</code></pre> <p>To run linters</p> <pre><code>$ hatch run pre-commit run --all-files\n</code></pre>"},{"location":"contributing/how%20to%20contribute/","title":"How to contribute","text":"<p>We're grateful for your interest in contributing to this library!</p>"},{"location":"contributing/how%20to%20contribute/#asking-questions","title":"Asking questions","text":"<p>If you have any question about this library, don't hesitate to ask!</p> <p>For more information on how to get in touch, see our Community Portal. In particular, we have a Community Chat, it's generally the best place to ask questions.</p>"},{"location":"contributing/how%20to%20contribute/#providing-feedback-requesting-features-and-filing-bugs","title":"Providing feedback, requesting features and filing bugs","text":"<p>We're very interested in your feedback!</p> <p>The best way to request a change, whether it's an improvement, a new feature or a bugfix, is through GitHub issues. Before filing a new issue, don't forget to search if there's already an issue on the same topic.</p> <p>If you're willing to help getting that issue resolved, that's even better! See the next section.</p>"},{"location":"contributing/how%20to%20contribute/#opening-pull-requests","title":"Opening Pull Requests","text":"<p>We're grateful for your Pull Requests (i.e. submissions) to the code, documentation, tutorials, even this document!</p> <p>Before your first Pull Request, you'll need to:</p> <ol> <li>Fork the repository;</li> <li>Clone your forked repository locally, either through the GitHub console, or <pre><code>$ git clone git@github.com:YOUR_USERNAME/maximum-independent-set.git\n$ cd maximum-independent-set\n$ git remote add upstream https://github.com/pasqal-io/maximum-independent-set.git\n</code></pre></li> <li>Setup your development environment.</li> </ol> <p>Before you open a Pull Request, please make sure that you have:</p> <ul> <li>read the contributor agreement</li> <li>followed all the testing instructions.</li> </ul> <p>Our testing infrastructure will check whether your changes to the code or documentation break anything. If they don't, this will start the review cycle, during which we'll discuss with you to understand the purpose of your change, fix any issue and, hopefully, get your code merged!</p>"},{"location":"contributing/how%20to%20contribute/#one-word-about-patents","title":"One word about patents","text":"<p>The domain of Quantum Computing is heavily patented. If you contribute a new quantum algorithm (and not just an improvement to the library), please make sure that it's not covered by a patent!</p>"},{"location":"contributing/releasing/","title":"Releasing a new version","text":"<p>You only need to read this document if you're a maintainer of this library.</p> <p>Steps to release a new version:</p> <ol> <li>Bump up the version number in pyproject.toml (e.g. <code>0.7.9</code>).</li> <li>Bump up the links in the <code>README.md</code> that point to specific versions of the documentation.</li> <li>Open a Pull Request.</li> <li>Get it merged.</li> <li>Optionally, test a pre-release<ol> <li>Open the GitHub \"draft new release\" panel.</li> <li>Create a new tag (e.g. <code>v0.7.9rc1</code>).</li> <li>Mark the release as \"pre-release\".</li> <li>Confirm the release.</li> <li>Check in the Actions that the <code>publish</code> action has succeeded.</li> </ol> </li> <li>Actually release.<ol> <li>Open the GitHub \"draft new release\" panel.</li> <li>Create a new tag (e.g. <code>v0.7.9rc1</code>).</li> <li>Mark the release as \"latest release\".</li> <li>Confirm the release.</li> <li>Check in the Actions that the <code>publish</code> action has succeeded.</li> </ol> </li> </ol>"},{"location":"api/mis/","title":"Reference","text":"<p>mis</p>"},{"location":"api/mis/coloring/","title":"mis.coloring","text":"mis.coloring<p> source package mis.coloring </p> <p> Classes </p> <ul> <li> <p>GraphColoringSolver \u2014 GraphColoringSolver class to solve the graph coloring problem for antennas using the Maximum Independent Set (MIS) approach. Given the coordinates of antennas and a specified antenna range, it finds a coloring of the graph such that no two antennas in the range of each other share the same color.</p> </li> </ul> <p> source class GraphColoringSolver(loader: DataLoader, antenna_range: float, config: SolverConfig = SolverConfig()) </p> <p>Bases : BaseSolver</p> <p>GraphColoringSolver class to solve the graph coloring problem for antennas using the Maximum Independent Set (MIS) approach. Given the coordinates of antennas and a specified antenna range, it finds a coloring of the graph such that no two antennas in the range of each other share the same color.</p> <p>Initialize the GraphColoringSolver with a DataLoader instance and antenna range. Args:     loader (DataLoader): An instance of DataLoader to load antenna coordinates.     antenna_range (float): The maximum distance within which antennas can interfere with each other.     config (SolverConfig): Configuration for the MIS solver, including backend and other settings.</p> <p> Attributes </p> <ul> <li> <p>loader :  DataLoader \u2014 An instance of DataLoader to load antenna coordinates.</p> </li> <li> <p>antenna_range :  float \u2014 The maximum distance within which antennas can interfere with each other.</p> </li> <li> <p>colors :  list[int] \u2014 A list where the index represents the antenna and the value represents its color.</p> </li> <li> <p>colors_count :  int \u2014 The total number of colors used in the solution.</p> </li> <li> <p>solver_config :  SolverConfig \u2014 Configuration for the MIS solver, including backend and other settings.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>solve \u2014 Solve the graph coloring problem by finding a maximum independent set for the given antenna range and coloring the antennas accordingly.</p> </li> <li> <p>split_antennas_by_degree \u2014 Splits the antennas into two sets based on a threshold of the degree of the node. Antennas with a degree less than or equal to the threshold will be grouped together.</p> </li> <li> <p>reduce_colors \u2014 Attempts to reduce the number of colors used in the solution by trying to reassign every node of some color. Returns :     list[int]: A list of colors for each antenna, where the index represents the antenna.</p> </li> <li> <p>check_solution \u2014 Check if the solution is valid by ensuring that no two antennas in the same color are within the antenna range of each other.</p> </li> <li> <p>visualize_solution \u2014 Visualize the solution by plotting the antennas on a 2D plane. Each antenna is represented by a point, and antennas that are in the same independent set (i.e., do not interfere with each other) are colored the same.</p> </li> </ul> <p> source method GraphColoringSolver.solve(antennas: Optional[set[int]] = None, is_second_coloring: bool = False) \u2192 list[MISSolution] </p> <p>Solve the graph coloring problem by finding a maximum independent set for the given antenna range and coloring the antennas accordingly.</p> <p> Parameters </p> <ul> <li> <p>antennas :  set[int] \u2014 A set of antenna indices to consider for coloring. If empty, all antennas in the dataset will be considered.</p> </li> <li> <p>is_second_coloring :  bool \u2014 If True, the solver will not reset the colors count and will continue coloring from the last used color.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Execution[list[MISSolution]] \u2014 An execution object containing the nodes of each color in the solution.</p> </li> </ul> <p> source method GraphColoringSolver.split_antennas_by_degree(threshold: int) \u2192 list[set[int]] </p> <p>Splits the antennas into two sets based on a threshold of the degree of the node. Antennas with a degree less than or equal to the threshold will be grouped together.</p> <p> Parameters </p> <ul> <li> <p>threshold :  int \u2014 The degree threshold for splitting antennas.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[set[int]] \u2014 A list of sets, where the first set contains antennas with a degree less than or equal to the threshold, and the second set contains the rest.</p> </li> </ul> <p> source method GraphColoringSolver.reduce_colors() \u2192 list[int] </p> <p>Attempts to reduce the number of colors used in the solution by trying to reassign every node of some color. Returns :     list[int]: A list of colors for each antenna, where the index represents the antenna.</p> <p> source method GraphColoringSolver.check_solution() \u2192 bool </p> <p>Check if the solution is valid by ensuring that no two antennas in the same color are within the antenna range of each other.</p> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the solution is valid, False otherwise.</p> </li> </ul> <p> source method GraphColoringSolver.visualize_solution() \u2192 plt </p> <p>Visualize the solution by plotting the antennas on a 2D plane. Each antenna is represented by a point, and antennas that are in the same independent set (i.e., do not interfere with each other) are colored the same.</p> <p> Returns </p> <ul> <li> <p>plt \u2014 A matplotlib plot object showing the antenna coverage solution.</p> </li> </ul>"},{"location":"api/mis/coloring/coloring/","title":"mis.coloring.coloring","text":"mis.coloring.coloring<p> source module mis.coloring.coloring </p> <p> Classes </p> <ul> <li> <p>GraphColoringSolver \u2014 GraphColoringSolver class to solve the graph coloring problem for antennas using the Maximum Independent Set (MIS) approach. Given the coordinates of antennas and a specified antenna range, it finds a coloring of the graph such that no two antennas in the range of each other share the same color.</p> </li> </ul> <p> source class GraphColoringSolver(loader: DataLoader, antenna_range: float, config: SolverConfig = SolverConfig()) </p> <p>Bases : BaseSolver</p> <p>GraphColoringSolver class to solve the graph coloring problem for antennas using the Maximum Independent Set (MIS) approach. Given the coordinates of antennas and a specified antenna range, it finds a coloring of the graph such that no two antennas in the range of each other share the same color.</p> <p>Initialize the GraphColoringSolver with a DataLoader instance and antenna range. Args:     loader (DataLoader): An instance of DataLoader to load antenna coordinates.     antenna_range (float): The maximum distance within which antennas can interfere with each other.     config (SolverConfig): Configuration for the MIS solver, including backend and other settings.</p> <p> Attributes </p> <ul> <li> <p>loader :  DataLoader \u2014 An instance of DataLoader to load antenna coordinates.</p> </li> <li> <p>antenna_range :  float \u2014 The maximum distance within which antennas can interfere with each other.</p> </li> <li> <p>colors :  list[int] \u2014 A list where the index represents the antenna and the value represents its color.</p> </li> <li> <p>colors_count :  int \u2014 The total number of colors used in the solution.</p> </li> <li> <p>solver_config :  SolverConfig \u2014 Configuration for the MIS solver, including backend and other settings.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>solve \u2014 Solve the graph coloring problem by finding a maximum independent set for the given antenna range and coloring the antennas accordingly.</p> </li> <li> <p>split_antennas_by_degree \u2014 Splits the antennas into two sets based on a threshold of the degree of the node. Antennas with a degree less than or equal to the threshold will be grouped together.</p> </li> <li> <p>reduce_colors \u2014 Attempts to reduce the number of colors used in the solution by trying to reassign every node of some color. Returns :     list[int]: A list of colors for each antenna, where the index represents the antenna.</p> </li> <li> <p>check_solution \u2014 Check if the solution is valid by ensuring that no two antennas in the same color are within the antenna range of each other.</p> </li> <li> <p>visualize_solution \u2014 Visualize the solution by plotting the antennas on a 2D plane. Each antenna is represented by a point, and antennas that are in the same independent set (i.e., do not interfere with each other) are colored the same.</p> </li> </ul> <p> source method GraphColoringSolver.solve(antennas: Optional[set[int]] = None, is_second_coloring: bool = False) \u2192 list[MISSolution] </p> <p>Solve the graph coloring problem by finding a maximum independent set for the given antenna range and coloring the antennas accordingly.</p> <p> Parameters </p> <ul> <li> <p>antennas :  set[int] \u2014 A set of antenna indices to consider for coloring. If empty, all antennas in the dataset will be considered.</p> </li> <li> <p>is_second_coloring :  bool \u2014 If True, the solver will not reset the colors count and will continue coloring from the last used color.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Execution[list[MISSolution]] \u2014 An execution object containing the nodes of each color in the solution.</p> </li> </ul> <p> source method GraphColoringSolver.split_antennas_by_degree(threshold: int) \u2192 list[set[int]] </p> <p>Splits the antennas into two sets based on a threshold of the degree of the node. Antennas with a degree less than or equal to the threshold will be grouped together.</p> <p> Parameters </p> <ul> <li> <p>threshold :  int \u2014 The degree threshold for splitting antennas.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[set[int]] \u2014 A list of sets, where the first set contains antennas with a degree less than or equal to the threshold, and the second set contains the rest.</p> </li> </ul> <p> source method GraphColoringSolver.reduce_colors() \u2192 list[int] </p> <p>Attempts to reduce the number of colors used in the solution by trying to reassign every node of some color. Returns :     list[int]: A list of colors for each antenna, where the index represents the antenna.</p> <p> source method GraphColoringSolver.check_solution() \u2192 bool </p> <p>Check if the solution is valid by ensuring that no two antennas in the same color are within the antenna range of each other.</p> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the solution is valid, False otherwise.</p> </li> </ul> <p> source method GraphColoringSolver.visualize_solution() \u2192 plt </p> <p>Visualize the solution by plotting the antennas on a 2D plane. Each antenna is represented by a point, and antennas that are in the same independent set (i.e., do not interfere with each other) are colored the same.</p> <p> Returns </p> <ul> <li> <p>plt \u2014 A matplotlib plot object showing the antenna coverage solution.</p> </li> </ul>"},{"location":"api/mis/data/","title":"mis.data","text":"mis.data<p> source package mis.data </p> <p> Classes </p> <ul> <li> <p>DataLoader \u2014 DataLoader class to handle loading of coordinates from CSV files, calculating distances between coordinates, and building a Maximum Independent Set (MIS) instance.</p> </li> </ul> <p> source class DataLoader() </p> <p>DataLoader class to handle loading of coordinates from CSV files, calculating distances between coordinates, and building a Maximum Independent Set (MIS) instance.</p> <p> Attributes </p> <ul> <li> <p>coordinates_dataset :  list[tuple[float, float]] \u2014 A list of tuples representing coordinates (latitude, longitude).</p> </li> </ul> <p> Methods </p> <ul> <li> <p>distance_from_coordinates \u2014 Calculate the distance between two geodesic coordinates.</p> </li> <li> <p>load_from_csv_coordinates \u2014 Load coordinates from a CSV file. The CSV file should have a column named 'coordonnees' with coordinates in the format \"lat,lon\".</p> </li> <li> <p>build_mis_instance_from_coordinates \u2014 Build a Maximum Independent Set (MIS) instance from the loaded coordinates. The function creates a graph where nodes represent antennas and edges represent connections between antennas that are within the specified range. Args:     antenna_range (float): The maximum distance between antennas to consider them connected.     antennas (set[int], optional): A set of indices representing the antennas to include in the graph.                                    If None, all antennas in the dataset are included. Returns:     MISInstance: An instance of the Maximum Independent Set problem represented as a graph.</p> </li> </ul> <p> source staticmethod DataLoader.distance_from_coordinates(coord1: tuple[float, float], coord2: tuple[float, float]) \u2192 float </p> <p>Calculate the distance between two geodesic coordinates.</p> <p> Parameters </p> <ul> <li> <p>coord1 :  tuple[float, float] \u2014 The first coordinate as a tuple (latitude, longitude).</p> </li> <li> <p>coord2 :  tuple[float, float] \u2014 The second coordinate as a tuple (latitude, longitude).</p> </li> </ul> <p> Returns </p> <ul> <li> <p>float \u2014 The distance between the two coordinates in kilometers.</p> </li> </ul> <p> source method DataLoader.load_from_csv_coordinates(file_path: Path) \u2192 None </p> <p>Load coordinates from a CSV file. The CSV file should have a column named 'coordonnees' with coordinates in the format \"lat,lon\".</p> <p> Parameters </p> <ul> <li> <p>file_path :  Path \u2014 The path to the CSV file containing coordinates.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>FileNotFoundError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method DataLoader.build_mis_instance_from_coordinates(antenna_range: float, antennas: set[int] = None) \u2192 MISInstance </p> <p>Build a Maximum Independent Set (MIS) instance from the loaded coordinates. The function creates a graph where nodes represent antennas and edges represent connections between antennas that are within the specified range. Args:     antenna_range (float): The maximum distance between antennas to consider them connected.     antennas (set[int], optional): A set of indices representing the antennas to include in the graph.                                    If None, all antennas in the dataset are included. Returns:     MISInstance: An instance of the Maximum Independent Set problem represented as a graph.</p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul>"},{"location":"api/mis/data/dataloader/","title":"mis.data.dataloader","text":"mis.data.dataloader<p> source module mis.data.dataloader </p> <p> Classes </p> <ul> <li> <p>DataLoader \u2014 DataLoader class to handle loading of coordinates from CSV files, calculating distances between coordinates, and building a Maximum Independent Set (MIS) instance.</p> </li> </ul> <p> source class DataLoader() </p> <p>DataLoader class to handle loading of coordinates from CSV files, calculating distances between coordinates, and building a Maximum Independent Set (MIS) instance.</p> <p> Attributes </p> <ul> <li> <p>coordinates_dataset :  list[tuple[float, float]] \u2014 A list of tuples representing coordinates (latitude, longitude).</p> </li> </ul> <p> Methods </p> <ul> <li> <p>distance_from_coordinates \u2014 Calculate the distance between two geodesic coordinates.</p> </li> <li> <p>load_from_csv_coordinates \u2014 Load coordinates from a CSV file. The CSV file should have a column named 'coordonnees' with coordinates in the format \"lat,lon\".</p> </li> <li> <p>build_mis_instance_from_coordinates \u2014 Build a Maximum Independent Set (MIS) instance from the loaded coordinates. The function creates a graph where nodes represent antennas and edges represent connections between antennas that are within the specified range. Args:     antenna_range (float): The maximum distance between antennas to consider them connected.     antennas (set[int], optional): A set of indices representing the antennas to include in the graph.                                    If None, all antennas in the dataset are included. Returns:     MISInstance: An instance of the Maximum Independent Set problem represented as a graph.</p> </li> </ul> <p> source staticmethod DataLoader.distance_from_coordinates(coord1: tuple[float, float], coord2: tuple[float, float]) \u2192 float </p> <p>Calculate the distance between two geodesic coordinates.</p> <p> Parameters </p> <ul> <li> <p>coord1 :  tuple[float, float] \u2014 The first coordinate as a tuple (latitude, longitude).</p> </li> <li> <p>coord2 :  tuple[float, float] \u2014 The second coordinate as a tuple (latitude, longitude).</p> </li> </ul> <p> Returns </p> <ul> <li> <p>float \u2014 The distance between the two coordinates in kilometers.</p> </li> </ul> <p> source method DataLoader.load_from_csv_coordinates(file_path: Path) \u2192 None </p> <p>Load coordinates from a CSV file. The CSV file should have a column named 'coordonnees' with coordinates in the format \"lat,lon\".</p> <p> Parameters </p> <ul> <li> <p>file_path :  Path \u2014 The path to the CSV file containing coordinates.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>FileNotFoundError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method DataLoader.build_mis_instance_from_coordinates(antenna_range: float, antennas: set[int] = None) \u2192 MISInstance </p> <p>Build a Maximum Independent Set (MIS) instance from the loaded coordinates. The function creates a graph where nodes represent antennas and edges represent connections between antennas that are within the specified range. Args:     antenna_range (float): The maximum distance between antennas to consider them connected.     antennas (set[int], optional): A set of indices representing the antennas to include in the graph.                                    If None, all antennas in the dataset are included. Returns:     MISInstance: An instance of the Maximum Independent Set problem represented as a graph.</p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul>"},{"location":"api/mis/data/graphs/","title":"mis.data.graphs","text":"mis.data.graphs<p> source module mis.data.graphs </p> <p>Loading graphs as raw data.</p> <p> Classes </p> <ul> <li> <p>DIMACSDataset \u2014 A dataset representing a DIMACS graph instance and its solutions. This is used to load DIMACS files and extract the graph and solutions.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>load_dimacs \u2014 Load a DIMACS file and return a DIMACSDataset.</p> </li> </ul> <p> source dataclass DIMACSDataset(instance: MISInstance, solutions: list[list[int]]) </p> <p>A dataset representing a DIMACS graph instance and its solutions. This is used to load DIMACS files and extract the graph and solutions.</p> <p> Attributes </p> <ul> <li> <p>solutions :  list[list[int]] \u2014 If the dataset provided solutions, the list of solutions. Note that most instances do not provide a solution and those that do do not guarantee that they provide all solutions.</p> </li> </ul> <p> source load_dimacs(path: Path) \u2192 DIMACSDataset </p> <p>Load a DIMACS file and return a DIMACSDataset.</p> <p> Parameters </p> <ul> <li> <p>path :  Path \u2014 Path to the DIMACS file.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>DIMACSDataset \u2014 An instance of DIMACSDataset.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul>"},{"location":"api/mis/pipeline/","title":"mis.pipeline","text":"mis.pipeline<p> source package mis.pipeline </p> <p>The algorithm pipeline.</p> <p>Most users will probably be interested in module <code>mis.pipeline.config</code>.</p> <p> Modules </p> <ul> <li> <p>mis.pipeline.basesolver \u2014 Shared definitions for solvers.</p> </li> <li> <p>mis.pipeline.config \u2014 Configuration for MIS solvers.</p> </li> <li> <p>mis.pipeline.embedder \u2014 Tools to prepare the geometry (register) of atoms.</p> </li> <li> <p>mis.pipeline.fixtures</p> </li> <li> <p>mis.pipeline.kernelization</p> </li> <li> <p>mis.pipeline.layout</p> </li> <li> <p>mis.pipeline.maximization</p> </li> <li> <p>mis.pipeline.postprocessor</p> </li> <li> <p>mis.pipeline.preprocessor</p> </li> <li> <p>mis.pipeline.pulse</p> </li> </ul>"},{"location":"api/mis/pipeline/basesolver/","title":"mis.pipeline.basesolver","text":"mis.pipeline.basesolver<p> source module mis.pipeline.basesolver </p> <p>Shared definitions for solvers.</p> <p>This module is useful mostly for users interested in writing new solvers.</p> <p> Classes </p> <ul> <li> <p>BaseSolver \u2014 Abstract base class for all solvers (quantum or classical).</p> </li> </ul> <p> source class BaseSolver(instance: MISInstance, config: SolverConfig) </p> <p>Bases : ABC</p> <p>Abstract base class for all solvers (quantum or classical).</p> <p>Provides the interface for solving, embedding, pulse shaping, and execution of MISproblems.</p> <p>The BaseSolver also provides a method to execute the Pulse and Register</p> <p>Initialize the solver with the MISinstance and configuration.</p> <p> Parameters </p> <ul> <li> <p>instance :  MISInstance \u2014 The MISproblem to solve.</p> </li> <li> <p>config :  SolverConfig \u2014 Configuration settings for the solver.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>solve \u2014 Solve the given MISinstance.</p> </li> </ul> <p> source method BaseSolver.solve() \u2192 list[MISSolution] </p> <p>Solve the given MISinstance.</p> <p> Returns </p> <ul> <li> <p>list[MISSolution] \u2014 A list of solutions, ranked from best (lowest energy) to worst (highest energy).</p> </li> </ul>"},{"location":"api/mis/pipeline/config/","title":"mis.pipeline.config","text":"mis.pipeline.config<p> source module mis.pipeline.config </p> <p>Configuration for MIS solvers.</p> <p> Classes </p> <ul> <li> <p>BackendConfig \u2014 Generic configuration for backends.</p> </li> <li> <p>BackendType \u2014 Type of backend to use for solving the QUBO.</p> </li> <li> <p>SolverConfig \u2014 Configuration class for setting up solver parameters.</p> </li> <li> <p>GreedyConfig \u2014 Configuration for greedy solving strategies.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>default_preprocessor \u2014 Instantiate the default preprocessor.</p> </li> <li> <p>default_postprocessor \u2014 Instantiate the default postprocessor.</p> </li> </ul> <p> class BackendConfig(**data: Any) </p> <p>Bases : pydantic.BaseModel</p> <p>Generic configuration for backends.</p> <p>Create a new model by parsing and validating input data from keyword arguments.</p> <p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> <p> Attributes </p> <ul> <li> <p>model_config :  ClassVar[ConfigDict] \u2014 Configuration for the model, should be a dictionary conforming to [<code>ConfigDict</code>][pydantic.config.ConfigDict].</p> </li> <li> <p>model_extra :  dict[str, Any] | None \u2014 Get extra fields set during validation.</p> </li> <li> <p>model_fields_set :  set[str] \u2014 Returns the set of fields that have been explicitly set on this model instance.</p> </li> <li> <p>backend :  BackendType \u2014 The type of backend to use.</p> </li> <li> <p>username :  str | None \u2014 For a backend that requires authentication, such as Pasqal Cloud,.</p> </li> <li> <p>password :  str | None \u2014 For a backend that requires authentication, such as Pasqal Cloud,.</p> </li> <li> <p>project_id :  str | None \u2014 For a backend that associates jobs to projects, such as Pasqal Cloud,.</p> </li> <li> <p>device :  NamedDevice | DeviceType | None</p> </li> <li> <p>dt :  int \u2014 For a backend that supports customizing the duration of steps, the.</p> </li> </ul> <p> enum BackendType() </p> <p>Bases : StrEnum</p> <p>Type of backend to use for solving the QUBO.</p> <p> Attributes </p> <ul> <li> <p>QUTIP</p> </li> <li> <p>REMOTE_QPU</p> </li> <li> <p>REMOTE_EMUMPS</p> </li> <li> <p>EMU_MPS</p> </li> <li> <p>EMU_SV</p> </li> </ul> <p> source dataclass SolverConfig(backend: BaseBackend | BackendConfig | None = None, method: MethodType = MethodType.EAGER, max_iterations: int = 1, max_number_of_solutions: int = 1, device: Device | None = None, embedder: BaseEmbedder | None = None, pulse_shaper: BasePulseShaper | None = None, preprocessor: Callable[[nx.Graph], BasePreprocessor] | None = field(default_factory=default_preprocessor), postprocessor: Callable[[], BasePostprocessor] | None = default_postprocessor, greedy: GreedyConfig = field(default_factory=GreedyConfig), runs: int = 500) </p> <p>Configuration class for setting up solver parameters.</p> <p> Attributes </p> <ul> <li> <p>backend :  BaseBackend | BackendConfig | None \u2014 Backend configuration to use. If <code>None</code>, use a non-quantum heuristic solver.</p> </li> <li> <p>method :  MethodType \u2014 The method used to solve this instance of MIS.</p> </li> <li> <p>max_iterations :  int \u2014 Maximum number of iterations allowed for solving.</p> </li> <li> <p>max_number_of_solutions :  int \u2014 A maximal number of solutions to return.</p> </li> <li> <p>device :  Device | None \u2014 Quantum device to execute the code in. If unspecified, use a reasonable default device.</p> </li> <li> <p>embedder :  BaseEmbedder | None \u2014 If specified, an embedder, i.e. a mechanism used     to customize the layout of neutral atoms on the quantum     device. Ignored for non-quantum backends.</p> </li> <li> <p>pulse_shaper :  BasePulseShaper | None \u2014 If specified, a pulse shaper, i.e. a mechanism used     to customize the laser pulse to which the neutral atoms are     subjected during the execution of the quantum algorithm.     Ignored for non-quantum backends.</p> </li> <li> <p>preprocessor :  Callable[[nx.Graph], BasePreprocessor] | None \u2014 A graph preprocessor, used to decrease     the size of the graph (hence the duration of actual resolution)     by applying heuristics prior to embedding on a quantum device.</p> </li> <li> <p>postprocessor :  Callable[[], BasePostprocessor] | None \u2014 A postprocessor used to sort out and improve results.</p> </li> <li> <p>greedy :  GreedyConfig \u2014 If specified, use this for solving the GreedyMIS. Needs to be specified when method is GreedyMIS</p> </li> <li> <p>runs :  int \u2014 When using a quantum backend, how many times we repeat each quantum run. Since quantum executions are non-deterministic, higher numbers increases the reliability of the result, but also the duration until the results are available.</p> </li> </ul> <p> source default_preprocessor() \u2192 Callable[[nx.Graph], BasePreprocessor] </p> <p>Instantiate the default preprocessor.</p> <p>As of this writing, the default preprocessor is mis.pipeline.kernelization.Kernelization.</p> <p> source default_postprocessor() \u2192 BasePostprocessor </p> <p>Instantiate the default postprocessor.</p> <p>As of this writing, the default postprocessor is mis.pipeline.maximization.Maximization.</p> <p> source dataclass GreedyConfig(default_solving_threshold: int = 2, subgraph_quantity: int = 5, mis_sample_quantity: int = 1) </p> <p>Configuration for greedy solving strategies.</p> <p> Attributes </p> <ul> <li> <p>default_solving_threshold :  int \u2014 Size threshold (number of nodes) for using MIS solving when greedy method is used.</p> </li> <li> <p>subgraph_quantity :  int \u2014 Number of candidate subgraphs to generate during greedy mapping.</p> </li> <li> <p>mis_sample_quantity :  int \u2014 Number of MIS solutions to sample per iteration (if applicable).</p> </li> </ul>"},{"location":"api/mis/pipeline/embedder/","title":"mis.pipeline.embedder","text":"mis.pipeline.embedder<p> source module mis.pipeline.embedder </p> <p>Tools to prepare the geometry (register) of atoms.</p> <p> Classes </p> <ul> <li> <p>BaseEmbedder \u2014 Abstract base class for all embedders.</p> </li> <li> <p>DefaultEmbedder \u2014 A simple embedder</p> </li> </ul> <p> source class BaseEmbedder() </p> <p>Bases : ABC</p> <p>Abstract base class for all embedders.</p> <p>Prepares the geometry (register) of atoms based on the MISinstance. Returns a Register compatible with Pasqal/Pulser devices.</p> <p> Methods </p> <ul> <li> <p>embed \u2014 Creates a layout of atoms as the register.</p> </li> </ul> <p> source method BaseEmbedder.embed(instance: MISInstance, config: SolverConfig, backend: BaseBackend) \u2192 Register </p> <p>Creates a layout of atoms as the register.</p> <p> Returns </p> <ul> <li> <p>Register \u2014 The register.</p> </li> </ul> <p> source class DefaultEmbedder() </p> <p>Bases : BaseEmbedder</p> <p>A simple embedder</p> <p> Methods </p> <ul> <li> <p>embed</p> </li> </ul> <p> source method DefaultEmbedder.embed(instance: MISInstance, config: SolverConfig, backend: BaseBackend) \u2192 Register </p>"},{"location":"api/mis/pipeline/fixtures/","title":"mis.pipeline.fixtures","text":"mis.pipeline.fixtures<p> source module mis.pipeline.fixtures </p> <p> Classes </p> <ul> <li> <p>Fixtures \u2014 Handles all preprocessing and postprocessing logic for MIS problems.</p> </li> </ul> <p> source class Fixtures(instance: MISInstance, config: SolverConfig) </p> <p>Handles all preprocessing and postprocessing logic for MIS problems.</p> <p>This class allows centralized transformation or validation of the problem instance before solving, and modification or annotation of the solution after solving.</p> <p>Initialize the fixture handler with the MIS instance and solver config.</p> <p> Parameters </p> <ul> <li> <p>instance :  MISInstance \u2014 The problem instance to process.</p> </li> <li> <p>config :  SolverConfig \u2014 Solver configuration, which may include flags for enabling or customizing processing behavior.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>preprocess \u2014 Apply preprocessing steps to the MIS instance before solving.</p> </li> <li> <p>rebuild \u2014 Apply any pending rebuild operations to convert solutions on preprocessed graphs into solutions on the original graph.</p> </li> <li> <p>postprocess</p> </li> </ul> <p> source method Fixtures.preprocess() \u2192 MISInstance </p> <p>Apply preprocessing steps to the MIS instance before solving.</p> <p> Returns </p> <ul> <li> <p>MISInstance \u2014 The processed or annotated instance.</p> </li> </ul> <p> source method Fixtures.rebuild(solution: MISSolution) \u2192 MISSolution </p> <p>Apply any pending rebuild operations to convert solutions on preprocessed graphs into solutions on the original graph.</p> <p> Parameters </p> <ul> <li> <p>solution :  MISSolution \u2014 The raw solution from a solver.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>MISSolution \u2014 The cleaned or transformed solution.</p> </li> </ul> <p> source method Fixtures.postprocess(solutions: list[MISSolution]) \u2192 list[MISSolution] </p>"},{"location":"api/mis/pipeline/kernelization/","title":"mis.pipeline.kernelization","text":"mis.pipeline.kernelization<p> source module mis.pipeline.kernelization </p> <p> Classes </p> <ul> <li> <p>BaseKernelization \u2014 Shared base class for kernelization.</p> </li> <li> <p>Kernelization \u2014 Apply well-known transformations to the graph to reduce its size without compromising the result.</p> </li> <li> <p>BaseRebuilder \u2014 The pre-processing operations attempt to remove edges and/or vertices from the original graph. Therefore, when we build a MIS for these reduced graphs (the \"partial solution\"), we may end up with a solution that does not work for the original graph.</p> </li> <li> <p>RebuilderIsolatedNodeRemoval</p> </li> <li> <p>RebuilderNodeFolding</p> </li> <li> <p>RebuilderUnconfined</p> </li> <li> <p>RebuilderTwinIndependent</p> </li> <li> <p>RebuilderTwinHasDependency</p> </li> </ul> <p> source class BaseKernelization(graph: nx.Graph) </p> <p>Bases : BasePreprocessor, abc.ABC</p> <p>Shared base class for kernelization.</p> <p> Methods </p> <ul> <li> <p>preprocess</p> </li> <li> <p>rebuild \u2014 Rebuild a MIS solution to the original graph from a partial MIS solution on the reduced graph obtained by kernelization.</p> </li> <li> <p>is_independent \u2014 Determine if a set of nodes represents an independent set within a given graph.</p> </li> <li> <p>is_subclique \u2014 Determine whether a list of nodes represents a clique within the graph, i.e. whether every pair of nodes is connected.</p> </li> <li> <p>is_isolated \u2014 Determine whether a node is isolated, i.e. this node + its neighbours represent a clique.</p> </li> </ul> <p> source method BaseKernelization.preprocess() \u2192 nx.Graph </p> <p> source method BaseKernelization.rebuild(partial_solution: set[int]) \u2192 set[int] </p> <p>Rebuild a MIS solution to the original graph from a partial MIS solution on the reduced graph obtained by kernelization.</p> <p> source method BaseKernelization.is_independent(nodes: list[int]) \u2192 bool </p> <p>Determine if a set of nodes represents an independent set within a given graph.</p> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the nodes in <code>nodes</code> represent an independent     set within <code>graph</code>. False otherwise, i.e. if there's at least one connection     between two nodes of <code>nodes</code></p> </li> </ul> <p> source method BaseKernelization.is_subclique(nodes: list[int]) \u2192 bool </p> <p>Determine whether a list of nodes represents a clique within the graph, i.e. whether every pair of nodes is connected.</p> <p> source method BaseKernelization.is_isolated(node: int) \u2192 bool </p> <p>Determine whether a node is isolated, i.e. this node + its neighbours represent a clique.</p> <p> source class Kernelization(graph: nx.Graph) </p> <p>Bases : BaseKernelization</p> <p>Apply well-known transformations to the graph to reduce its size without compromising the result.</p> <p> This algorithm is adapted from e.g. </p> <p>https://schulzchristian.github.io/thesis/masterarbeit_demian_hespe.pdf</p> <p> Methods </p> <ul> <li> <p>preprocess \u2014 Apply all rules, exhaustively, until the graph cannot be reduced further, storing the rules for rebuilding after the fact.</p> </li> <li> <p>apply_rule_isolated_node_removal</p> </li> <li> <p>search_rule_isolated_node_removal \u2014 Remove any isolated node (see <code>is_isolated</code> for a definition).</p> </li> <li> <p>apply_rule_node_fold</p> </li> <li> <p>search_rule_node_fold \u2014 If a node V has exactly two neighbours U and X and there is no edge between U and X, fold U, V and X and into a single node.</p> </li> <li> <p>aux_search_confinement</p> </li> <li> <p>apply_rule_unconfined</p> </li> <li> <p>unconfined_loop</p> </li> <li> <p>search_rule_unconfined_and_diamond</p> </li> <li> <p>fold_twin</p> </li> <li> <p>find_twin \u2014 Find a twin of a node, i.e. another node with the same neighbours.</p> </li> <li> <p>apply_rule_twin_independent</p> </li> <li> <p>apply_rule_twin_has_dependency</p> </li> <li> <p>search_rule_twin_reduction \u2014 If a node has exactly 3 neighbours and a twin (another node with the exact same neighbours), we can merge the 5 nodes.</p> </li> </ul> <p> source method Kernelization.preprocess() \u2192 nx.Graph </p> <p>Apply all rules, exhaustively, until the graph cannot be reduced further, storing the rules for rebuilding after the fact.</p> <p> source method Kernelization.apply_rule_isolated_node_removal(isolated: int) \u2192 None </p> <p> source method Kernelization.search_rule_isolated_node_removal() \u2192 None </p> <p>Remove any isolated node (see <code>is_isolated</code> for a definition).</p> <p> source method Kernelization.apply_rule_node_fold(v: int, u: int, x: int) \u2192 None </p> <p> source method Kernelization.search_rule_node_fold() \u2192 None </p> <p>If a node V has exactly two neighbours U and X and there is no edge between U and X, fold U, V and X and into a single node.</p> <p> source method Kernelization.aux_search_confinement(neighbors_S: set[int], S: set[int]) \u2192 tuple[int, int, set[int]] </p> <p> source method Kernelization.apply_rule_unconfined(v: int) \u2192 None </p> <p> source method Kernelization.unconfined_loop(v: int, S: set[int], neighbors_S: set[int]) \u2192 bool </p> <p> source method Kernelization.search_rule_unconfined_and_diamond() \u2192 None </p> <p> source method Kernelization.fold_twin(u: int, v: int, v_prime: int, neighbors_u: list[int]) \u2192 None </p> <p> source method Kernelization.find_twin(v: int) \u2192 int | None </p> <p>Find a twin of a node, i.e. another node with the same neighbours.</p> <p> source method Kernelization.apply_rule_twin_independent(v: int, u: int, neighbors_u: list[int]) \u2192 None </p> <p> source method Kernelization.apply_rule_twin_has_dependency(v: int, u: int, neighbors_u: list[int]) \u2192 None </p> <p> source method Kernelization.search_rule_twin_reduction() \u2192 None </p> <p>If a node has exactly 3 neighbours and a twin (another node with the exact same neighbours), we can merge the 5 nodes.</p> <p> source class BaseRebuilder() </p> <p>Bases : abc.ABC</p> <p>The pre-processing operations attempt to remove edges and/or vertices from the original graph. Therefore, when we build a MIS for these reduced graphs (the \"partial solution\"), we may end up with a solution that does not work for the original graph.</p> <p>Each rebuilder corresponds to one of the operations that previously reduced the size of the graph, and is charged with adapting the MIS solution to the greater graph.</p> <p> Methods </p> <ul> <li> <p>rebuild</p> </li> </ul> <p> source method BaseRebuilder.rebuild(partial_solution: set[int]) \u2192 None </p> <p> source class RebuilderIsolatedNodeRemoval(isolated: int) </p> <p>Bases : BaseRebuilder</p> <p> Methods </p> <ul> <li> <p>rebuild</p> </li> </ul> <p> source method RebuilderIsolatedNodeRemoval.rebuild(partial_solution: set[int]) \u2192 None </p> <p> source class RebuilderNodeFolding(v: int, u: int, x: int, v_prime: int) </p> <p>Bases : BaseRebuilder</p> <p> Methods </p> <ul> <li> <p>rebuild</p> </li> </ul> <p> source method RebuilderNodeFolding.rebuild(partial_solution: set[int]) \u2192 None </p> <p> source class RebuilderUnconfined() </p> <p>Bases : BaseRebuilder</p> <p> Methods </p> <ul> <li> <p>rebuild</p> </li> </ul> <p> source method RebuilderUnconfined.rebuild(partial_solution: set[int]) \u2192 None </p> <p> source class RebuilderTwinIndependent(v: int, u: int, w_0: int, w_1: int, w_2: int, v_prime: int) </p> <p>Bases : BaseRebuilder</p> <p> Invariants </p> <ul> <li>U has exactly 3 neighbours W0, W1, W2;</li> <li>V has exactly the same neighbours as U;</li> <li>there is no self-loop around U or V (hence U and V are not    neighbours);</li> <li>there is no edge between W1, W2, W3;</li> <li>V' is the node obtained by merging U, V, W1, W2, W3.</li> </ul> <p> Methods </p> <ul> <li> <p>rebuild</p> </li> </ul> <p> source method RebuilderTwinIndependent.rebuild(partial_solution: set[int]) \u2192 None </p> <p> source class RebuilderTwinHasDependency(v: int, u: int) </p> <p>Bases : BaseRebuilder</p> <p> Invariants </p> <ul> <li>U has exactly 3 neighbours;</li> <li>V has exactly the same neighbours as U;</li> <li>there is no self-loop around U;</li> <li>there is at least one connection between two neighbours of U.</li> </ul> <p> Methods </p> <ul> <li> <p>rebuild</p> </li> </ul> <p> source method RebuilderTwinHasDependency.rebuild(partial_solution: set[int]) \u2192 None </p>"},{"location":"api/mis/pipeline/layout/","title":"mis.pipeline.layout","text":"mis.pipeline.layout<p> source module mis.pipeline.layout </p> <p> Classes </p> <ul> <li> <p>Layout \u2014 A 2D layout class for quantum layout embedding.</p> </li> </ul> <p> source class Layout(data: MISInstance | dict[int, tuple[float, float]], rydberg_blockade: float) </p> <p>A 2D layout class for quantum layout embedding.</p> <p> Accepts either </p> <ul> <li>dict[int, tuple[float, float]] of coordinates     mapping from node (int) to physical coordinates (x, y)     UNIT = \"\u00b5m\"</li> <li>MISInstance (graph)</li> </ul> <p> Methods </p> <ul> <li> <p>from_device \u2014 Creates a Layout using <code>device.min_atom_distance</code> as the blockade, and rescales coordinates so no pair is too close.</p> </li> <li> <p>draw</p> </li> <li> <p>num_nodes</p> </li> <li> <p>grid_size</p> </li> </ul> <p> source classmethod Layout.from_device(data: MISInstance | dict[int, tuple[float, float]], device: Device) \u2192 Layout </p> <p>Creates a Layout using <code>device.min_atom_distance</code> as the blockade, and rescales coordinates so no pair is too close.</p> <p> source method Layout.draw() \u2192 None </p> <p> source method Layout.num_nodes() \u2192 int </p> <p> source method Layout.grid_size() \u2192 int </p>"},{"location":"api/mis/pipeline/maximization/","title":"mis.pipeline.maximization","text":"mis.pipeline.maximization<p> source module mis.pipeline.maximization </p> <p> Classes </p> <ul> <li> <p>Maximization \u2014 A postprocessor dedicated to improving MIS results provided by a quantum algorithm.</p> </li> </ul> <p> source class Maximization(frequency_threshold: float = 1e-07, augment_rounds: int = 10, seed: int = 0) </p> <p>Bases : BasePostprocessor</p> <p>A postprocessor dedicated to improving MIS results provided by a quantum algorithm.</p> <p>This postprocessor expects that a result could be vulnerable to bitflips, so it will attempt to fix any result provided by the quantum algorithm, to make it independent (if it's not independent) and maximal (if it's not maximal).</p> <p>frequency_threshold: Minimal frequency to check. Discard any solution which show     up with a frequency &lt;= frequency_threshold. Set 0 to never discard any solution. augment_rounds: The number of attempts to augment an independent set to     add possibly missing nodes. seed: A random seed.</p> <p> Methods </p> <ul> <li> <p>postprocess \u2014 The main entry point: attempt to improve a solution.</p> </li> <li> <p>is_independent_solution \u2014 Check whether a solution is independent.</p> </li> <li> <p>is_independent_list \u2014 Check whether a list of nodes within a graph is independent.</p> </li> <li> <p>augment_to_maximal \u2014 Augment a given set up to a maximal IS using a greedy algorithm running k times.</p> </li> <li> <p>reduce_to_independence \u2014 Reduce the given candidate solution to an independent state of graph g.</p> </li> </ul> <p> source method Maximization.postprocess(solution: MISSolution) \u2192 MISSolution | None </p> <p>The main entry point: attempt to improve a solution.</p> <p> source method Maximization.is_independent_solution(solution: MISSolution) \u2192 bool </p> <p>Check whether a solution is independent.</p> <p> source method Maximization.is_independent_list(graph: nx.Graph, nodes: list[int]) \u2192 bool </p> <p>Check whether a list of nodes within a graph is independent.</p> <p> source method Maximization.augment_to_maximal(solution: MISSolution) \u2192 MISSolution </p> <p>Augment a given set up to a maximal IS using a greedy algorithm running k times.</p> <p>See https://doi.org/10.48550/arXiv.2202.09372 section 2.3 of supplementary material for reference.</p> <p> source method Maximization.reduce_to_independence(solution: MISSolution) \u2192 MISSolution </p> <p>Reduce the given candidate solution to an independent state of graph g.</p> <p>We progressively remove the nodes with highest number of neighbours.</p> <p>See https://doi.org/10.48550/arXiv.2202.09372 section 2.3 of supplementary material for reference.</p>"},{"location":"api/mis/pipeline/postprocessor/","title":"mis.pipeline.postprocessor","text":"mis.pipeline.postprocessor<p> source module mis.pipeline.postprocessor </p> <p> Classes </p> <ul> <li> <p>BasePostprocessor</p> </li> </ul> <p> source class BasePostprocessor() </p> <p>Bases : abc.ABC</p> <p> Methods </p> <ul> <li> <p>postprocess \u2014 Post-process a solution, typically to improve its quality.</p> </li> </ul> <p> source method BasePostprocessor.postprocess(solution: MISSolution) \u2192 MISSolution | None </p> <p>Post-process a solution, typically to improve its quality.</p> <p>May return <code>None</code> if the solution is deemed unacceptable.</p>"},{"location":"api/mis/pipeline/preprocessor/","title":"mis.pipeline.preprocessor","text":"mis.pipeline.preprocessor<p> source module mis.pipeline.preprocessor </p> <p> Classes </p> <ul> <li> <p>BasePreprocessor \u2014 Base class for preprocessors.</p> </li> </ul> <p> source class BasePreprocessor() </p> <p>Bases : abc.ABC</p> <p>Base class for preprocessors.</p> <p> Methods </p> <ul> <li> <p>preprocess</p> </li> <li> <p>rebuild</p> </li> </ul> <p> source method BasePreprocessor.preprocess() \u2192 nx.Graph </p> <p> source method BasePreprocessor.rebuild(partial_solution: set[int]) \u2192 set[int] </p>"},{"location":"api/mis/pipeline/pulse/","title":"mis.pipeline.pulse","text":"mis.pipeline.pulse<p> source module mis.pipeline.pulse </p> <p> Classes </p> <ul> <li> <p>BasePulseShaper \u2014 Abstract base class for generating pulse schedules based on a MIS problem.</p> </li> <li> <p>DefaultPulseShaper \u2014 A simple pulse shaper.</p> </li> </ul> <p> source dataclass BasePulseShaper(duration_us: int | None = None) </p> <p>Bases : ABC</p> <p>Abstract base class for generating pulse schedules based on a MIS problem.</p> <p>This class transforms the structure of a MISInstance into a quantum pulse sequence that can be applied to a physical register. The register is passed at the time of pulse generation, not during initialization.</p> <p> Attributes </p> <ul> <li> <p>duration_us :  int | None \u2014 The duration of the pulse, in microseconds.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>generate \u2014 Generate a pulse based on the problem and the provided register.</p> </li> </ul> <p> source method BasePulseShaper.generate(config: SolverConfig, register: Register, backend: BaseBackend, instance: MISInstance) \u2192 Pulse </p> <p>Generate a pulse based on the problem and the provided register.</p> <p> Parameters </p> <ul> <li> <p>config :  SolverConfig \u2014 The configuration for this pulse.</p> </li> <li> <p>register :  Register \u2014 The physical register layout.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Pulse \u2014 A generated pulse object wrapping a Pulser pulse.</p> </li> </ul> <p> source dataclass DefaultPulseShaper(duration_us: int | None = None) </p> <p>Bases : BasePulseShaper</p> <p>A simple pulse shaper.</p> <p> Attributes </p> <ul> <li> <p>duration_us :  int | None \u2014 The duration of the pulse, in microseconds.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>generate \u2014 Return a simple constant waveform pulse</p> </li> </ul> <p> source method DefaultPulseShaper.generate(config: SolverConfig, register: Register, backend: BaseBackend, instance: MISInstance) \u2192 Pulse </p> <p>Return a simple constant waveform pulse</p>"},{"location":"api/mis/shared/","title":"mis.shared","text":"mis.shared<p> source package mis.shared </p> <p>Shared utility code.</p> <p> Modules </p> <ul> <li> <p>mis.shared.error \u2014 Exceptions raised within this library.</p> </li> <li> <p>mis.shared.graphs</p> </li> <li> <p>mis.shared.retrier \u2014 Backoff-and-retry utilities.</p> </li> <li> <p>mis.shared.types</p> </li> </ul>"},{"location":"api/mis/shared/error/","title":"mis.shared.error","text":"mis.shared.error<p> source module mis.shared.error </p> <p>Exceptions raised within this library.</p> <p> Classes </p> <ul> <li> <p>GraphError \u2014 An error raised when attempting to compile a graph, for any reason.</p> </li> <li> <p>MappingError \u2014 An error raised when a graph-to-layout mapping fails validation, such as when node placements violate adjacency or physical layout constraints.</p> </li> <li> <p>CompilationError \u2014 An error raised when attempting to compile a graph for an architecture that does not support it, e.g. because it requires too many qubits or because the physical constraints on the geometry are not satisfied.</p> </li> <li> <p>ExecutionError</p> </li> </ul> <p> source class GraphError() </p> <p>Bases : ValueError</p> <p>An error raised when attempting to compile a graph, for any reason.</p> <p> source class MappingError() </p> <p>Bases : ValueError</p> <p>An error raised when a graph-to-layout mapping fails validation, such as when node placements violate adjacency or physical layout constraints.</p> <p> source class CompilationError() </p> <p>Bases : GraphError</p> <p>An error raised when attempting to compile a graph for an architecture that does not support it, e.g. because it requires too many qubits or because the physical constraints on the geometry are not satisfied.</p> <p> source class ExecutionError() </p> <p>Bases : Exception</p>"},{"location":"api/mis/shared/graphs/","title":"mis.shared.graphs","text":"mis.shared.graphs<p> source module mis.shared.graphs </p> <p> Functions </p> <ul> <li> <p>calculate_weight \u2014 Calculates the total weight of a set of nodes in a given MISInstance</p> </li> <li> <p>is_independent \u2014 Checks if the node set is an independent set (no edges between them).</p> </li> <li> <p>remove_neighborhood \u2014 Removes a node and all its neighbors from the graph.</p> </li> </ul> <p> source calculate_weight(graph: nx.Graph, nodes: list[int]) \u2192 float </p> <p>Calculates the total weight of a set of nodes in a given MISInstance</p> <p> Parameters </p> <ul> <li> <p>graph :  nx.Graph \u2014 The graph to check.</p> </li> <li> <p>nodes :  list[int] \u2014 List of node indices.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>float \u2014 Total weight as a float.</p> </li> </ul> <p> source is_independent(graph: nx.Graph, nodes: list[int]) \u2192 bool </p> <p>Checks if the node set is an independent set (no edges between them).</p> <p> Parameters </p> <ul> <li> <p>graph :  nx.Graph \u2014 The graph to check.</p> </li> <li> <p>nodes :  list[int] \u2014 The set of nodes.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if independent, False otherwise.</p> </li> </ul> <p> source remove_neighborhood(graph: nx.Graph, nodes: list[int]) \u2192 nx.Graph </p> <p>Removes a node and all its neighbors from the graph.</p> <p> Parameters </p> <ul> <li> <p>graph :  nx.Graph \u2014 The graph to modify.</p> </li> <li> <p>nodes :  list[int] \u2014 List of nodes to remove.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>nx.Graph \u2014 The reduced graph.</p> </li> </ul>"},{"location":"api/mis/shared/retrier/","title":"mis.shared.retrier","text":"mis.shared.retrier<p> source module mis.shared.retrier </p> <p>Backoff-and-retry utilities.</p> <p> Classes </p> <ul> <li> <p>PygRetrier \u2014 Our test harness attempts to run tests concurrently, but the pyg dataset loader does not work well with concurrency.</p> </li> </ul> <p> source class PygRetrier(max_attempts: int = 3, name: str = 'PygRetrier') </p> <p>Our test harness attempts to run tests concurrently, but the pyg dataset loader does not work well with concurrency.</p> <p>We work around this by simply retrying the loads a few times, until it succeeds.</p> <p>Create a PygRetrier</p> <p> Parameters </p> <ul> <li> <p>max_attempts :  optional \u2014 The max number of attempts to undertake before giving up. Defaults to 3.</p> </li> <li> <p>name :  optional \u2014 A name to use during logging.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>insist \u2014 Attempt to call a function or constructor repeatedly until, hopefully, it works.</p> </li> </ul> <p> source method PygRetrier.insist(callback: Type[Dataset], **kwargs: Any) \u2192 Dataset </p> <p>Attempt to call a function or constructor repeatedly until, hopefully, it works.</p> <p> Raises </p> <ul> <li> <p>exn</p> </li> </ul>"},{"location":"api/mis/shared/types/","title":"mis.shared.types","text":"mis.shared.types<p> source module mis.shared.types </p> <p> Classes </p> <ul> <li> <p>MethodType</p> </li> <li> <p>MISInstance</p> </li> <li> <p>MISSolution \u2014 A solution to a MIS problem.</p> </li> </ul> <p> source enum MethodType() </p> <p>Bases : str, Enum</p> <p> Attributes </p> <ul> <li> <p>EAGER</p> </li> <li> <p>GREEDY</p> </li> </ul> <p> source class MISInstance(graph: networkx.Graph) </p> <p> Methods </p> <ul> <li> <p>draw \u2014 Draw instance graph with highlighted nodes.</p> </li> </ul> <p> source method MISInstance.draw(nodes: list[int] | None = None, node_size: int = 600, highlight_color: str = 'darkgreen', font_family: str = 'Century Gothic') \u2192 None </p> <p>Draw instance graph with highlighted nodes.</p> <p> Parameters </p> <ul> <li> <p>```</p> </li> <li> <p>nodes :  list[int] \u2014 List of nodes to highlight.</p> </li> <li> <p>node_size :  int \u2014 Size of drawn nodes in drawn graph. (default: 600)</p> </li> <li> <p>highlight_color :  str \u2014 Color to highlight nodes with. (default: \"darkgreen\")</p> </li> <li> <p>```</p> </li> </ul> <p> Raises </p> <ul> <li> <p>Exception</p> </li> </ul> <p> source class MISSolution(instance: MISInstance, nodes: list[int], frequency: float) </p> <p>A solution to a MIS problem.</p> <p> Attributes </p> <ul> <li> <p>instance :  MISInstance \u2014 The MIS instance to which this class represents a solution.</p> </li> <li> <p>size :  int \u2014 The number of nodes in this solution.</p> </li> <li> <p>node_indices :  list[int] \u2014 The indices of the nodes of <code>instance</code> picked in this solution.</p> </li> <li> <p>nodes :  list[Any] \u2014 The nodes of <code>instance</code> picked in this solution.</p> </li> <li> <p>frequency :  float \u2014 How often this solution showed up in the measures, where 0. represents a solution that never showed up in the meaures and 1. a solution that showed up in all measures.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>draw \u2014 Draw instance graph with solution nodes highlighted.</p> </li> </ul> <p> source method MISSolution.draw(node_size: int = 600, highlight_color: str = 'darkgreen', font_family: str = 'Century Gothic') \u2192 None </p> <p>Draw instance graph with solution nodes highlighted.</p> <p> Parameters </p> <ul> <li> <p>```</p> </li> <li> <p>node_size :  int \u2014 Size of drawn nodes in drawn graph. (default: 600)</p> </li> <li> <p>highlight_color :  str \u2014 Color to highlight solution nodes with. (default: \"darkgreen\")</p> </li> <li> <p>font :  str \u2014 Font type</p> </li> <li> <p>```</p> </li> </ul>"}]}