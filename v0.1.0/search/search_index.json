{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Maximum independent set","text":"<p>The Maximum Independent Set (MIS) library provides a flexible, powerful, and user-friendly Python interface for solving Maximum Independent Set problem using Quantum technologies. It is designed for scientists and engineers working on optimization problems\u2014no quantum computing knowledge required and no quantum computer needed for testing.</p> <p>This library lets users treat the solver as a black box: feed in a graph, get back an optimal (or near-optimal) independent set. For more advanced users, it offers tools to fine-tune algorithmic strategies, leverage quantum hardware via the Pasqal cloud, or even experiment with custom quantum sequences and processing pipelines.</p> <p>Users setting their first steps into quantum computing will learn how to implement the core algorithm in a few simple steps and run it using the Pasqal Neutral Atom QPU. More experienced users will find this library to provide the right environment to explore new ideas - both in terms of methodologies and data domain - while always interacting with a simple and intuitive QPU interface.</p>"},{"location":"#getting-in-touch","title":"Getting in touch","text":"<ul> <li>Pasqal Community Portal (forums, chat, tutorials, examples, code library).</li> <li>GitHub Repository (source code, issue tracker).</li> <li>Professional Support (if you need tech support, custom licenses, a variant of this library optimized for your workload, your own QPU, remote access to a QPU, ...)</li> </ul>"},{"location":"#contribute","title":"Contribute","text":"<p>The GitHub repository is open for contributions!</p> <p>Don't forget to read the Contributor License Agreement.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/","title":"Contributor Agreement","text":"<p>PASQAL CONTRIBUTION AGREEMENT (the \u201cAgreement\u201d)</p> <p>The author of the License is:   Pasqal, a Soci\u00e9t\u00e9 par Actions Simplifi\u00e9e (Simplified Joint Stock Company) registered under number 849 441 522 at the Registre du commerce et des soci\u00e9t\u00e9s (Trade and Companies Register) of Evry \u2013 France, headquartered at 24 rue \u00c9mile Baudot \u2013 91120 \u2013 Palaiseau \u2013 France, duly represented by its Pr\u00e9sident, M. Georges-Olivier REYMOND, Hereafter referred to as \u00ab the Licensor \u00bb</p> <p>In the course of its activities, Pasqal carries out and leads quantic projects, in their software components. These projects aim to bring together a community of like-minded individuals to contribute to the development and improvement of Pasqal\u2019s products. Pasqal clearly outlines which projects are open to contributions (\u201cProjects\u201d).</p> <p>This Agreement documents the rights granted by Contributors to Pasqal and is legally binding.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-1-definitions","title":"Article 1 Definitions","text":"<p>You, Your or Contributor : means the intellectual property rights owner or legal entity authorized by the intellectual property rights owner that is entering into this Agreement with\u00a0Pasqal</p> <p>Contribution : means any work, protected or not, that is submitted by You to Pasqal in which You own or assert ownership of the intellectual property rights, subject to proprietary licensing terms, and not otherwise distributer through an open-source license.</p> <p>Material : means the work object of the Project, made available by Pasqal to third parties. When this Agreement covers more than one Project, the Material means the work to which the Contribution was Submitted. After You Submit the Contribution, it may be included in any type of Material.</p> <p>Submit : means any form of electronic, verbal, or written communication sent to Pasqal or its representatives, including but not limited to electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, Pasqal for the purpose of discussing and improving the Material.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-2-entering-into-this-agreement","title":"Article 2 Entering into this Agreement","text":"<p>By Submitting any Contribution to Pasqal, You agree to enter into the Agreement with this entity, and be bound by the following terms.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-3-limitations-as-to-the-licensing-of-contributions","title":"Article 3 Limitations as to the licensing of Contributions","text":"<p>You guarantee that any Contribution You Submit to any Project is not licensed under any type of contaminating (even weakly contaminating) license, and that Pasqal will be free to combine your Contribution into any type of Material, for any Project, without any risk of contamination of said Material and/or Project.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-4-granting-of-a-copyright-andor-authors-rights-license","title":"Article 4 Granting of a Copyright and/or author\u2019s rights License","text":"<p>Subject to the terms and conditions of this Agreement, You hereby grant to Pasqal and to recipients of any Project distributed by Pasqal a worldwide, sublicensable, non-exclusive, royalty-free license to reproduce, prepare derivative works of, publicly display, publicly perform, and distribute Your Contributions and your Contribution in combination with the Material for the entire duration of the rights under Applicable law.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-5-granting-of-a-patent-license","title":"Article 5 Granting of a patent license","text":"<p>Subject to the terms and conditions of this Agreement, You grant Pasqal a, worldwide, non-exclusive, transferable, royalty free patent license, with the right to sublicense these rights to third parties, to make, have made, use, sell, offer for sale, import and otherwise  transfer the Contribution and the Contribution in combination with the Material for the entire duration of the rights under Applicable law, if the Contribution implies the implementation of any such patent.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-6-licensing-of-the-material-and-contribution","title":"Article 6 Licensing of the Material and Contribution","text":"<p>Based on the rights granted in articles 2 and 3, if Pasqal includes Your Contribution in a Material, Pasqal may license Material including Your Contribution under any license, whether permissive, weakly contaminating, or contaminating. Pasqal will respect Your moral rights in relation to Your Contribution as provided under the Applicable law.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-7-warranties-and-disclaimer","title":"Article 7 Warranties and disclaimer","text":"<p>You represent that each of Your Contributions is Your creation, or that you have obtained the authorization from the intellectual property rights owner on the Contribution to Submit it over the course of a Project.</p> <p>By making a Contribution, You confirm that, to the best of Your knowledge, the Contribution does not violate the rights of any person or entity. If You make a Contribution on behalf of Your employer, then You confirm that an appropriate representative of that employer has authorized the inclusion of such Contribution to a Project and that it meets these requirements.</p> <p>You acknowledge that Pasqal is not obligated to use Your Contribution as part of the Material and may decide to only include Contributions Pasqal considers appropriate.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-8-applicable-law-and-jurisdiction","title":"Article 8 Applicable law and jurisdiction","text":"<p>The Agreement is governed by the laws of France. Any dispute relating to the interpretation or application of the License shall be subject to best efforts for an amicable settlement. Any dispute relating to the License, notably its execution, performance and/or termination shall be brought to, heard and tried by the Tribunal Judiciaire de Paris, regardless of the rules of jurisdiction in the matter.</p>"},{"location":"LICENSE/","title":"Licence (MIT-Derived)","text":"<p>PASQAL OPEN-SOURCE SOFTWARE LICENSE AGREEMENT (MIT-derived)</p> <p>The author of the License is:   Pasqal, a Soci\u00e9t\u00e9 par Actions Simplifi\u00e9e (Simplified Joint Stock Company) registered under number 849 441 522 at the Registre du commerce et des soci\u00e9t\u00e9s (Trade and Companies Register) of Evry \u2013 France, headquartered at 24 rue \u00c9mile Baudot \u2013 91120 \u2013 Palaiseau \u2013 France, duly represented by its Pr\u00e9sident, M. Georges-Olivier REYMOND, Hereafter referred to as \u00ab the Licensor \u00bb</p> <ul> <li> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software (the \u201cLicensee\u201d) and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. The Software is \u201cas is\u201d, without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and non-infringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise arising from, out of or in connection with the Software or the use or other dealings in the Software.</p> </li> <li> <p>If use of the Software leads to the necessary use of any patent of the Licensor and/or any of its Affiliates (defined as a company owned or controlled by the Licensor), the Licensee is granted a royalty-free license, in any country where such patent is in force, to use the object of such patent; or use the process covered by such patent,</p> </li> <li> <p>Such a patent license is granted for internal research or academic use of the Licensee's, which includes use by employees and students of the Licensee, acting on behalf of the Licensee, for research purposes only.</p> </li> <li> <p>The License is governed by the laws of France. Any dispute relating to the License, notably its execution, performance and/or termination shall be brought to, heard and tried by the Tribunal Judiciaire de Paris, regardless of the rules of jurisdiction in the matter.</p> </li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#using-hatch-uv-or-any-pyproject-compatible-python-manager","title":"Using <code>hatch</code>, <code>uv</code> or any pyproject-compatible Python manager","text":"<p>Edit file <code>pyproject.toml</code> to add the line</p> <pre><code>  \"maximum-independent-set\"\n</code></pre> <p>to the list of <code>dependencies</code>.</p>"},{"location":"installation/#using-pip-or-pipx","title":"Using <code>pip</code> or <code>pipx</code>","text":"<p>To install the <code>pipy</code> package using <code>pip</code> or <code>pipx</code></p> <ol> <li>Create a <code>venv</code> if that's not done yet</li> </ol> <pre><code>$ python -m venv venv\n</code></pre> <ol> <li>Enter the venv</li> </ol> <pre><code>$ . venv/bin/activate\n</code></pre> <ol> <li>Install the package</li> </ol> <pre><code>$ pip install maximum-independent-set\n# or\n$ pipx install maximum-independent-set\n</code></pre>"},{"location":"tutorials/","title":"High-Level tutorials","text":"<p>These tutorials will guide you, step-to-step, from loading graphs to solve MIS.</p> <ol> <li>Using a Quantum Device to solve MIS</li> <li>Example Use Case</li> </ol>"},{"location":"tutorials/#going-lower-level","title":"Going lower-level","text":"<p>At some point, you may decide that you need more control, or wish to understand better how the pipeline works. These tutorials will guide you through the same features using lower-level APIs.</p> <ol> <li>Backend and Solver Configuration</li> <li>Sampling &amp; Analysis</li> </ol>"},{"location":"usage/","title":"Usage","text":"<pre><code>from mis import MISSolver, MISInstance, SolverConfig\nfrom mis.pipeline.backends import QutipBackend\nimport networkx as nx\n\n# Generate a simple graph (here, a triangle)\ngraph = nx.Graph()\ngraph.add_edges_from([(0, 1), (0, 2)])\ninstance = MISInstance(graph)\n\n# Use a quantum solver.\nconfig = SolverConfig(backend=QutipBackend())\nsolver = MISSolver(instance, config)\n\n# Solve the MIS problem\nresults = solver.solve().result()\n\nprint(\"MIS solutions:\", results)\n</code></pre>"},{"location":"contributing/first%20contact/","title":"First contact","text":""},{"location":"contributing/first%20contact/#getting-the-code","title":"Getting the code","text":"<p>The code is available on GitHub.</p> <p>To clone it</p> <pre><code>$ git clone git@github.com:pasqal-io/quantum-evolution-kernel.git\n</code></pre> <p>or</p> <pre><code>$ git clone https://github.com/pasqal-io/quantum-evolution-kernel\n</code></pre>"},{"location":"contributing/first%20contact/#hatch-instructions","title":"Hatch instructions","text":"<p>We use <code>hatch</code> and Python 3.10 for development.</p>"},{"location":"contributing/first%20contact/#setting-up","title":"Setting up","text":"<p>With Python and pip installed, to setup the environment:</p> <pre><code>$ pip install hatch\n$ hatch -v shell\n</code></pre> <p>This will open a shell with all the dependencies installed.</p>"},{"location":"contributing/first%20contact/#running-tests","title":"Running tests","text":"<p>To run the unit and integration tests</p> <pre><code>$ hatch run test\n</code></pre> <p>To run linters</p> <pre><code>$ hatch run pre-commit run --all-files\n</code></pre>"},{"location":"contributing/how%20to%20contribute/","title":"How to contribute","text":"<p>We're grateful for your interest in contributing to this library!</p>"},{"location":"contributing/how%20to%20contribute/#asking-questions","title":"Asking questions","text":"<p>If you have any question about this library, don't hesitate to ask!</p> <p>For more information on how to get in touch, see our Community Portal. In particular, we have a Community Chat, it's generally the best place to ask questions.</p>"},{"location":"contributing/how%20to%20contribute/#providing-feedback-requesting-features-and-filing-bugs","title":"Providing feedback, requesting features and filing bugs","text":"<p>We're very interested in your feedback!</p> <p>The best way to request a change, whether it's an improvement, a new feature or a bugfix, is through GitHub issues. Before filing a new issue, don't forget to search if there's already an issue on the same topic.</p> <p>If you're willing to help getting that issue resolved, that's even better! See the next section.</p>"},{"location":"contributing/how%20to%20contribute/#opening-pull-requests","title":"Opening Pull Requests","text":"<p>We're grateful for your Pull Requests (i.e. submissions) to the code, documentation, tutorials, even this document!</p> <p>Before your first Pull Request, you'll need to:</p> <ol> <li>Fork the repository;</li> <li>Clone your forked repository locally, either through the GitHub console, or <pre><code>$ git clone git@github.com:YOUR_USERNAME/quantum-evolution-kernel.git\n$ cd quantum-evolution-kernel\n$ git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre></li> <li>Setup your development environment.</li> </ol> <p>Before you open a Pull Request, please make sure that you have:</p> <ul> <li>read the contributor agreement</li> <li>followed all the testing instructions.</li> </ul> <p>Our testing infrastructure will check whether your changes to the code or documentation break anything. If they don't, this will start the review cycle, during which we'll discuss with you to understand the purpose of your change, fix any issue and, hopefully, get your code merged!</p>"},{"location":"contributing/how%20to%20contribute/#one-word-about-patents","title":"One word about patents","text":"<p>The domain of Quantum Computing is heavily patented. If you contribute a new quantum algorithm (and not just an improvement to the library), please make sure that it's not covered by a patent!</p>"},{"location":"contributing/releasing/","title":"Releasing a new version","text":"<p>You only need to read this document if you're a maintainer of this library.</p> <p>Steps to release a new version:</p> <ol> <li>Bump up the version number in pyproject.toml (e.g. <code>0.7.9</code>).</li> <li>Bump up the links in the <code>README.md</code> that point to specific versions of the documentation.</li> <li>Open a Pull Request.</li> <li>Get it merged.</li> <li>Optionally, test a pre-release<ol> <li>Open the GitHub \"draft new release\" panel.</li> <li>Create a new tag (e.g. <code>v0.7.9rc1</code>).</li> <li>Mark the release as \"pre-release\".</li> <li>Confirm the release.</li> <li>Check in the Actions that the <code>publish</code> action has succeeded.</li> </ol> </li> <li>Actually release.<ol> <li>Open the GitHub \"draft new release\" panel.</li> <li>Create a new tag (e.g. <code>v0.7.9rc1</code>).</li> <li>Mark the release as \"latest release\".</li> <li>Confirm the release.</li> <li>Check in the Actions that the <code>publish</code> action has succeeded.</li> </ol> </li> </ol>"},{"location":"api/mis/","title":"Reference","text":"mis<p> source package mis </p> <p>Maximum Independent Set is a Python library that provides quantum solvers for the Maximum Independent Set problem.</p> <p>The Maximum Independent Set problem (or MIS) is a graph optimization problem with applications to numerous fields, e.g. scheduling, constraint solving, etc. The input of this problem is a set of nodes and a set of conflicts between these nodes. Solving MIS is finding the largest set of nodes that do not have conflicts. This problem is well-known for being NP-hard -- in other words, there are no known exact, non-exponential algorithms that can reliably solve the problem, forcing entire industries to rely upon heuristics. Quantum computers offer alternative approaches to solving a number of problems, including MIS, in reasonable time.</p> <p>The core of the library is a set of MIS solvers developed to be used on quantum devices, including quantum computers, for users who have access to one, or quantum emulators, for users who do not. We also provide non-quantum MIS solvers for benchmarking purposes.</p> <p> Classes </p> <ul> <li> <p>Execution \u2014 A task being sent to a quantum device and which may need some time before it is completed.</p> </li> <li> <p>MISInstance</p> </li> <li> <p>SolverConfig \u2014 Configuration class for setting up solver parameters.</p> </li> </ul> <p> source class Execution() </p> <p>Bases : abc.ABC, Generic[Result]</p> <p>A task being sent to a quantum device and which may need some time before it is completed.</p> <p> Methods </p> <ul> <li> <p>result</p> </li> <li> <p>wait</p> </li> <li> <p>status</p> </li> <li> <p>map \u2014 Apply a transformation to the result once it is complete.</p> </li> <li> <p>success \u2014 Shortcut to return a result that has already succeeded.</p> </li> </ul> <p> source method Execution.result() \u2192 Result </p> <p> source async method Execution.wait(self) \u2192 Result </p> <p> source method Execution.status() \u2192 Status </p> <p> source method Execution.map(transform: Callable[[Result], Transformed]) \u2192 Execution[Transformed] </p> <p>Apply a transformation to the result once it is complete.</p> <p> source classmethod Execution.success(result: Result) \u2192 Execution[Result] </p> <p>Shortcut to return a result that has already succeeded.</p> <p>Failure</p> <p>'MISSolver' not found in 'mis'.</p> <p>Failure</p> <p>'MISSolver.solve' not found in 'mis'.</p> <p> source class MISInstance(graph: networkx.Graph) </p> <p> Methods </p> <ul> <li> <p>draw \u2014 Draw instance graph with highlighted nodes.</p> </li> </ul> <p> source method MISInstance.draw(nodes: list[int] | None = None, node_size: int = 600, highlight_color: str = 'red') \u2192 None </p> <p>Draw instance graph with highlighted nodes.</p> <p> Parameters </p> <ul> <li> <p>```</p> </li> <li> <p>nodes :  list[int] \u2014 List of nodes to highlight.</p> </li> <li> <p>node_size :  int \u2014 Size of drawn nodes in drawn graph. (default: 600)</p> </li> <li> <p>highlight_color :  str \u2014 Color to highlight nodes with. (default: \"red\")</p> </li> <li> <p>```</p> </li> </ul> <p> Raises </p> <ul> <li> <p>Exception</p> </li> </ul> <p> source dataclass SolverConfig(use_quantum: bool = False, backend: BaseBackend | None = None, method: MethodType = MethodType.EAGER, max_iterations: int = 1, max_number_of_solutions: int = 1, device: Device | None = None, embedder: BaseEmbedder | None = None, pulse_shaper: BasePulseShaper | None = None, preprocessor: Callable[[nx.Graph], BasePreprocessor] | None = field(default_factory=default_preprocessor), postprocessor: Callable[[], BasePostprocessor] | None = default_postprocessor, greedy: GreedyConfig = field(default_factory=GreedyConfig)) </p> <p>Configuration class for setting up solver parameters.</p> <p> Attributes </p> <ul> <li> <p>use_quantum :  bool \u2014 Whether to use quantum hardware or simulation for solving.</p> </li> <li> <p>backend :  BaseBackend | None \u2014 Backend configuration to use. If <code>None</code>, use a non-quantum heuristic solver.</p> </li> <li> <p>method :  MethodType \u2014 The method used to solve this instance of MIS.</p> </li> <li> <p>max_iterations :  int \u2014 Maximum number of iterations allowed for solving.</p> </li> <li> <p>max_number_of_solutions :  int \u2014 A maximal number of solutions to return.</p> </li> <li> <p>device :  Device | None \u2014 Quantum device to execute the code in. If unspecified, use a reasonable default device.</p> </li> <li> <p>embedder :  BaseEmbedder | None \u2014 If specified, an embedder, i.e. a mechanism used     to customize the layout of neutral atoms on the quantum     device. Ignored for non-quantum backends.</p> </li> <li> <p>pulse_shaper :  BasePulseShaper | None \u2014 If specified, a pulse shaper, i.e. a mechanism used     to customize the laser pulse to which the neutral atoms are     subjected during the execution of the quantum algorithm.     Ignored for non-quantum backends.</p> </li> <li> <p>preprocessor :  Callable[[nx.Graph], BasePreprocessor] | None \u2014 A graph preprocessor, used to decrease     the size of the graph (hence the duration of actual resolution)     by applying heuristics prior to embedding on a quantum device.</p> </li> <li> <p>postprocessor :  Callable[[], BasePostprocessor] | None \u2014 A postprocessor used to sort out and improve results.</p> </li> <li> <p>greedy :  GreedyConfig \u2014 If specified, use this for solving the GreedyMIS. Needs to be specified when method is GreedyMIS</p> </li> </ul>"},{"location":"api/mis/pipeline/","title":"mis.pipeline","text":"mis.pipeline<p> source package mis.pipeline </p> <p>The algorithm pipeline.</p> <p>Most users will probably be interested in module <code>mis.pipeline.config</code>.</p> <p> Modules </p> <ul> <li> <p>mis.pipeline.backends \u2014 Executing a register and a sequence on a quantum device (including emulators).</p> </li> <li> <p>mis.pipeline.basesolver \u2014 Shared definitions for solvers.</p> </li> <li> <p>mis.pipeline.config \u2014 Configuration for MIS solvers.</p> </li> <li> <p>mis.pipeline.embedder \u2014 Tools to prepare the geometry (register) of atoms.</p> </li> <li> <p>mis.pipeline.execution</p> </li> <li> <p>mis.pipeline.executor</p> </li> <li> <p>mis.pipeline.fixtures</p> </li> <li> <p>mis.pipeline.kernelization</p> </li> <li> <p>mis.pipeline.layout</p> </li> <li> <p>mis.pipeline.maximization</p> </li> <li> <p>mis.pipeline.postprocessor</p> </li> <li> <p>mis.pipeline.preprocessor</p> </li> <li> <p>mis.pipeline.pulse</p> </li> <li> <p>mis.pipeline.targets \u2014 Code emitted by compilation.</p> </li> </ul>"},{"location":"api/mis/pipeline/backends/","title":"mis.pipeline.backends","text":"mis.pipeline.backends<p> source module mis.pipeline.backends </p> <p>Executing a register and a sequence on a quantum device (including emulators).</p> <p> Classes </p> <ul> <li> <p>BaseBackend \u2014 Low-level abstraction to execute a Register and a Pulse on a Quantum Device.</p> </li> <li> <p>QutipBackend \u2014 Execute a Register and a Pulse on the Qutip Emulator.</p> </li> <li> <p>BaseRemoteExecution \u2014 Execution on a remote device.</p> </li> <li> <p>BaseRemoteBackend \u2014 Base hierarch for remote backends.</p> </li> <li> <p>RemoteQPUBackend \u2014 Execute on a remote QPU.</p> </li> <li> <p>RemoteEmuMPSBackend \u2014 A backend that uses a remote high-performance emulator (EmuMPS) published on Pasqal Cloud.</p> </li> <li> <p>EmuMPSBackend \u2014 Execute a Register and a Pulse on the high-performance emu-mps Emulator.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>make_sequence \u2014 Build a Pulser sequence for a device from a pulse and a register.</p> </li> </ul> <p> source make_sequence(device: Device, pulse: targets.Pulse, register: targets.Register) \u2192 pulser.Sequence </p> <p>Build a Pulser sequence for a device from a pulse and a register.</p> <p>This function is mostly intended for internal use and will likely move to qool-layer in time.</p> <p> Parameters </p> <ul> <li> <p>device :  Device \u2014 The quantum device for which the sequence is built. Used to detect if a pulse + register is not compatible with a device.</p> </li> <li> <p>pulse :  targets.Pulse \u2014 The laser pulse to apply. It will be added as a Rydberg global channel.</p> </li> <li> <p>register :  targets.Register \u2014 The geometry for the sequence. If the device expects an automatic layout, this must already have been normalized with <code>with_automatic_layout</code>.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>CompilationError if the pulse + register are not compatible with the device.</p> </li> <li> <p>CompilationError</p> </li> </ul> <p> source class BaseBackend(device: Device) </p> <p>Bases : abc.ABC</p> <p>Low-level abstraction to execute a Register and a Pulse on a Quantum Device.</p> <p>For higher-level abstractions, see <code>BaseExtractor</code> and its subclasses.</p> <p>The sole role of these abstractions is to provide the same API for all backends. They might be removed in a future version, once Pulser has gained a similar API.</p> <p> Methods </p> <ul> <li> <p>device</p> </li> <li> <p>run</p> </li> </ul> <p> source method BaseBackend.device() \u2192 Device </p> <p> source method BaseBackend.run(register: targets.Register, pulse: targets.Pulse) \u2192 Execution[Counter[str]] </p> <p> Raises </p> <ul> <li> <p>NotImplementedError</p> </li> </ul> <p> source class QutipBackend(device: Device | None = None) </p> <p>Bases : BaseBackend</p> <p>Execute a Register and a Pulse on the Qutip Emulator.</p> <p>Please consider using EmuMPSBackend, which generally works much better with higher number of qubits.</p> <p> Performance warning </p> <p>Executing anything quantum related on an emulator takes an amount of resources polynomial in 2^N, where N is the number of qubits. This can easily go beyond the limit of the computer on which you're executing it.</p> <p> Methods </p> <ul> <li> <p>run \u2014 Execute a register and a pulse.</p> </li> </ul> <p> source method QutipBackend.run(register: targets.Register, pulse: targets.Pulse) \u2192 Execution[Counter[str]] </p> <p>Execute a register and a pulse.</p> <p> Parameters </p> <ul> <li> <p>register :  targets.Register \u2014 The register (geometry) to execute. Typically obtained by compiling a graph.</p> </li> <li> <p>pulse :  targets.Pulse \u2014 The pulse (lasers) to execute. Typically obtained by compiling a graph.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Execution[Counter[str]] \u2014 A bitstring Counter, i.e. a data structure counting for each bitstring the number of instances of this bitstring observed at the end of runs.</p> </li> </ul> <p> source class BaseRemoteExecution(sleep_sec: int, batch: Batch) </p> <p>Bases : WaitingExecution[Any]</p> <p>Execution on a remote device.</p> <p>Unless you're implementing a new backend, you probably want to use one of the subclasses.</p> <p> Methods </p> <ul> <li> <p>status</p> </li> <li> <p>result</p> </li> </ul> <p> source method BaseRemoteExecution.status() \u2192 Status </p> <p> source method BaseRemoteExecution.result() \u2192 Any </p> <p> Raises </p> <ul> <li> <p>ExecutionError</p> </li> </ul> <p> source class BaseRemoteBackend(project_id: str, username: str, device_name: str | None = None, password: str | None = None) </p> <p>Bases : BaseBackend</p> <p>Base hierarch for remote backends.</p> <p>Create a remote backend</p> <p> Performance warning </p> <p>As of this writing, using remote Backends to access a remote QPU or remote emulator is slower than using a RemoteExtractor, as the RemoteExtractor optimizes the number of connections used to communicate with the cloud server.</p> <p> Parameters </p> <ul> <li> <p>project_id :  str \u2014 The ID of the project on the Pasqal Cloud API.</p> </li> <li> <p>username :  str \u2014 Your username on the Pasqal Cloud API.</p> </li> <li> <p>password :  str | None \u2014 Your password on the Pasqal Cloud API. If you leave this to None, you will need to enter your password manually.</p> </li> <li> <p>device_name :  str | None \u2014 The name of the device to use. As of this writing, the default value of \"FRESNEL\" represents the latest QPU available through the Pasqal Cloud API.</p> </li> </ul> <p> source class RemoteQPUBackend(project_id: str, username: str, device_name: str | None = None, password: str | None = None) </p> <p>Bases : BaseRemoteBackend</p> <p>Execute on a remote QPU.</p> <p>Create a remote backend</p> <p> Performance note </p> <p>As of this writing, the waiting lines for a QPU may be very long. You may use this Extractor to resume your workflow with a computation that has been previously started.</p> <p> Parameters </p> <ul> <li> <p>project_id :  str \u2014 The ID of the project on the Pasqal Cloud API.</p> </li> <li> <p>username :  str \u2014 Your username on the Pasqal Cloud API.</p> </li> <li> <p>password :  str | None \u2014 Your password on the Pasqal Cloud API. If you leave this to None, you will need to enter your password manually.</p> </li> <li> <p>device_name :  str | None \u2014 The name of the device to use. As of this writing, the default value of \"FRESNEL\" represents the latest QPU available through the Pasqal Cloud API.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>run</p> </li> </ul> <p> source method RemoteQPUBackend.run(register: targets.Register, pulse: targets.Pulse) \u2192 Execution[Counter[str]] </p> <p> source class RemoteEmuMPSBackend(project_id: str, username: str, device_name: str | None = None, password: str | None = None) </p> <p>Bases : BaseRemoteBackend</p> <p>A backend that uses a remote high-performance emulator (EmuMPS) published on Pasqal Cloud.</p> <p>Create a remote backend</p> <p> Parameters </p> <ul> <li> <p>project_id :  str \u2014 The ID of the project on the Pasqal Cloud API.</p> </li> <li> <p>username :  str \u2014 Your username on the Pasqal Cloud API.</p> </li> <li> <p>password :  str | None \u2014 Your password on the Pasqal Cloud API. If you leave this to None, you will need to enter your password manually.</p> </li> <li> <p>device_name :  str | None \u2014 The name of the device to use. As of this writing, the default value of \"FRESNEL\" represents the latest QPU available through the Pasqal Cloud API.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>run</p> </li> </ul> <p> source method RemoteEmuMPSBackend.run(register: targets.Register, pulse: targets.Pulse, dt: int = 10) \u2192 Execution[Counter[str]] </p> <p> source class EmuMPSBackend(device: Device) </p> <p>Bases : BaseBackend</p> <p>Execute a Register and a Pulse on the high-performance emu-mps Emulator.</p> <p>As of this writing, this local emulator is only available under Unix. However, the RemoteEmuMPSBackend is available on all platforms.</p> <p> Performance warning </p> <p>Executing anything quantum related on an emulator takes an amount of resources polynomial in 2^N, where N is the number of qubits. This can easily go beyond the limit of the computer on which you're executing it.</p> <p> Methods </p> <ul> <li> <p>run</p> </li> </ul> <p> source method EmuMPSBackend.run(register: targets.Register, pulse: targets.Pulse, dt: int = 10) \u2192 Execution[Counter[str]] </p>"},{"location":"api/mis/pipeline/basesolver/","title":"mis.pipeline.basesolver","text":"mis.pipeline.basesolver<p> source module mis.pipeline.basesolver </p> <p>Shared definitions for solvers.</p> <p>This module is useful mostly for users interested in writing new solvers.</p> <p> Classes </p> <ul> <li> <p>BaseSolver \u2014 Abstract base class for all solvers (quantum or classical).</p> </li> </ul> <p> source class BaseSolver(instance: MISInstance, config: SolverConfig) </p> <p>Bases : ABC</p> <p>Abstract base class for all solvers (quantum or classical).</p> <p>Provides the interface for solving, embedding, pulse shaping, and execution of MISproblems.</p> <p>The BaseSolver also provides a method to execute the Pulse and Register</p> <p>Initialize the solver with the MISinstance and configuration.</p> <p> Parameters </p> <ul> <li> <p>instance :  MISInstance \u2014 The MISproblem to solve.</p> </li> <li> <p>config :  SolverConfig \u2014 Configuration settings for the solver.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>solve \u2014 Solve the given MISinstance.</p> </li> </ul> <p> source method BaseSolver.solve() \u2192 Execution[list[MISSolution]] </p> <p>Solve the given MISinstance.</p> <p> Returns </p> <ul> <li> <p>Execution[list[MISSolution]] \u2014 A list of solutions, ranked from best (lowest energy) to worst (highest energy).</p> </li> </ul>"},{"location":"api/mis/pipeline/config/","title":"mis.pipeline.config","text":"mis.pipeline.config<p> source module mis.pipeline.config </p> <p>Configuration for MIS solvers.</p> <p> Classes </p> <ul> <li> <p>SolverConfig \u2014 Configuration class for setting up solver parameters.</p> </li> <li> <p>GreedyConfig \u2014 Configuration for greedy solving strategies.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>default_preprocessor \u2014 Instantiate the default preprocessor.</p> </li> <li> <p>default_postprocessor \u2014 Instantiate the default postprocessor.</p> </li> </ul> <p> source dataclass SolverConfig(use_quantum: bool = False, backend: BaseBackend | None = None, method: MethodType = MethodType.EAGER, max_iterations: int = 1, max_number_of_solutions: int = 1, device: Device | None = None, embedder: BaseEmbedder | None = None, pulse_shaper: BasePulseShaper | None = None, preprocessor: Callable[[nx.Graph], BasePreprocessor] | None = field(default_factory=default_preprocessor), postprocessor: Callable[[], BasePostprocessor] | None = default_postprocessor, greedy: GreedyConfig = field(default_factory=GreedyConfig)) </p> <p>Configuration class for setting up solver parameters.</p> <p> Attributes </p> <ul> <li> <p>use_quantum :  bool \u2014 Whether to use quantum hardware or simulation for solving.</p> </li> <li> <p>backend :  BaseBackend | None \u2014 Backend configuration to use. If <code>None</code>, use a non-quantum heuristic solver.</p> </li> <li> <p>method :  MethodType \u2014 The method used to solve this instance of MIS.</p> </li> <li> <p>max_iterations :  int \u2014 Maximum number of iterations allowed for solving.</p> </li> <li> <p>max_number_of_solutions :  int \u2014 A maximal number of solutions to return.</p> </li> <li> <p>device :  Device | None \u2014 Quantum device to execute the code in. If unspecified, use a reasonable default device.</p> </li> <li> <p>embedder :  BaseEmbedder | None \u2014 If specified, an embedder, i.e. a mechanism used     to customize the layout of neutral atoms on the quantum     device. Ignored for non-quantum backends.</p> </li> <li> <p>pulse_shaper :  BasePulseShaper | None \u2014 If specified, a pulse shaper, i.e. a mechanism used     to customize the laser pulse to which the neutral atoms are     subjected during the execution of the quantum algorithm.     Ignored for non-quantum backends.</p> </li> <li> <p>preprocessor :  Callable[[nx.Graph], BasePreprocessor] | None \u2014 A graph preprocessor, used to decrease     the size of the graph (hence the duration of actual resolution)     by applying heuristics prior to embedding on a quantum device.</p> </li> <li> <p>postprocessor :  Callable[[], BasePostprocessor] | None \u2014 A postprocessor used to sort out and improve results.</p> </li> <li> <p>greedy :  GreedyConfig \u2014 If specified, use this for solving the GreedyMIS. Needs to be specified when method is GreedyMIS</p> </li> </ul> <p> source default_preprocessor() \u2192 Callable[[nx.Graph], BasePreprocessor] </p> <p>Instantiate the default preprocessor.</p> <p>As of this writing, the default preprocessor is mis.pipeline.kernelization.Kernelization.</p> <p> source default_postprocessor() \u2192 BasePostprocessor </p> <p>Instantiate the default postprocessor.</p> <p>As of this writing, the default postprocessor is mis.pipeline.maximization.Maximization.</p> <p> source dataclass GreedyConfig(exact_solving_threshold: int = 2, subgraph_quantity: int = 5, mis_sample_quantity: int = 1) </p> <p>Configuration for greedy solving strategies.</p> <p> Attributes </p> <ul> <li> <p>exact_solving_threshold :  int \u2014 Size threshold (number of nodes) for using MIS solving when greedy method is used.</p> </li> <li> <p>subgraph_quantity :  int \u2014 Number of candidate subgraphs to generate during greedy mapping.</p> </li> <li> <p>mis_sample_quantity :  int \u2014 Number of MIS solutions to sample per iteration (if applicable).</p> </li> </ul>"},{"location":"api/mis/pipeline/embedder/","title":"mis.pipeline.embedder","text":"mis.pipeline.embedder<p> source module mis.pipeline.embedder </p> <p>Tools to prepare the geometry (register) of atoms.</p> <p> Classes </p> <ul> <li> <p>BaseEmbedder \u2014 Abstract base class for all embedders.</p> </li> <li> <p>DefaultEmbedder \u2014 A simple embedder</p> </li> </ul> <p> source class BaseEmbedder() </p> <p>Bases : ABC</p> <p>Abstract base class for all embedders.</p> <p>Prepares the geometry (register) of atoms based on the MISinstance. Returns a Register compatible with Pasqal/Pulser devices.</p> <p> Methods </p> <ul> <li> <p>embed \u2014 Creates a layout of atoms as the register.</p> </li> </ul> <p> source method BaseEmbedder.embed(instance: MISInstance, config: SolverConfig) \u2192 Register </p> <p>Creates a layout of atoms as the register.</p> <p> Returns </p> <ul> <li> <p>Register \u2014 The register.</p> </li> </ul> <p> source class DefaultEmbedder() </p> <p>Bases : BaseEmbedder</p> <p>A simple embedder</p> <p> Methods </p> <ul> <li> <p>embed</p> </li> </ul> <p> source method DefaultEmbedder.embed(instance: MISInstance, config: SolverConfig) \u2192 Register </p>"},{"location":"api/mis/pipeline/execution/","title":"mis.pipeline.execution","text":"mis.pipeline.execution<p> source module mis.pipeline.execution </p> <p> Classes </p> <ul> <li> <p>Status</p> </li> <li> <p>Execution \u2014 A task being sent to a quantum device and which may need some time before it is completed.</p> </li> <li> <p>WaitingExecution \u2014 A task being sent to a quantum device and which definitely needs some time before it is completed.</p> </li> <li> <p>MappedExecution \u2014 The result of calling <code>map</code> on an <code>Execution</code>.</p> </li> <li> <p>SuccessfulExecution \u2014 An execution that is already completed.</p> </li> </ul> <p> source enum Status() </p> <p>Bases : str, Enum</p> <p> Attributes </p> <ul> <li> <p>IN_PROGRESS</p> </li> <li> <p>SUCCESS</p> </li> <li> <p>FAILURE</p> </li> </ul> <p> source class Execution() </p> <p>Bases : abc.ABC, Generic[Result]</p> <p>A task being sent to a quantum device and which may need some time before it is completed.</p> <p> Methods </p> <ul> <li> <p>result</p> </li> <li> <p>wait</p> </li> <li> <p>status</p> </li> <li> <p>map \u2014 Apply a transformation to the result once it is complete.</p> </li> <li> <p>success \u2014 Shortcut to return a result that has already succeeded.</p> </li> </ul> <p> source method Execution.result() \u2192 Result </p> <p> source async method Execution.wait(self) \u2192 Result </p> <p> source method Execution.status() \u2192 Status </p> <p> source method Execution.map(transform: Callable[[Result], Transformed]) \u2192 Execution[Transformed] </p> <p>Apply a transformation to the result once it is complete.</p> <p> source classmethod Execution.success(result: Result) \u2192 Execution[Result] </p> <p>Shortcut to return a result that has already succeeded.</p> <p> source class WaitingExecution(sleep_sec: int) </p> <p>Bases : Execution[Result]</p> <p>A task being sent to a quantum device and which definitely needs some time before it is completed.</p> <p>Unless you're implementing new executors, you're probably not interested in this class.</p> <p> Methods </p> <ul> <li> <p>wait</p> </li> </ul> <p> source async method WaitingExecution.wait(self) \u2192 Result </p> <p> source class MappedExecution(origin: Execution[Result], transform: Callable[[Result], Transformed]) </p> <p>Bases : Execution[Transformed]</p> <p>The result of calling <code>map</code> on an <code>Execution</code>.</p> <p>Unless you're implementing new executors, you're probably not interested in this class.</p> <p> Methods </p> <ul> <li> <p>result</p> </li> <li> <p>status</p> </li> <li> <p>wait</p> </li> </ul> <p> source method MappedExecution.result() \u2192 Transformed </p> <p> source method MappedExecution.status() \u2192 Status </p> <p> source async method MappedExecution.wait(self) \u2192 Transformed </p> <p> source class SuccessfulExecution(result: Result) </p> <p>Bases : Execution[Result]</p> <p>An execution that is already completed.</p> <p>Unless you're implementing new executors, you're probably not interested in this class.</p> <p> Methods </p> <ul> <li> <p>status</p> </li> <li> <p>wait</p> </li> <li> <p>result</p> </li> <li> <p>map</p> </li> </ul> <p> source method SuccessfulExecution.status() \u2192 Status </p> <p> source async method SuccessfulExecution.wait(self) \u2192 Result </p> <p> source method SuccessfulExecution.result() \u2192 Result </p> <p> source method SuccessfulExecution.map(transform: Callable[[Result], Transformed]) \u2192 Execution[Transformed] </p>"},{"location":"api/mis/pipeline/executor/","title":"mis.pipeline.executor","text":"mis.pipeline.executor<p> source module mis.pipeline.executor </p> <p> Classes </p> <ul> <li> <p>Executor \u2014 Responsible for submitting compiled register and pulse to a backend.</p> </li> </ul> <p> source class Executor(config: SolverConfig) </p> <p>Responsible for submitting compiled register and pulse to a backend.</p> <p> Parameters </p> <ul> <li> <p>config :  SolverConfig \u2014 Solver configuration, including backend and device info.</p> </li> <li> <p>register :  Register \u2014 The atom layout to execute.</p> </li> <li> <p>pulse :  Pulse \u2014 The control signal to execute.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>submit_job \u2014 Submits the job to the backend and returns a processed MISSolution.</p> </li> </ul> <p> source method Executor.submit_job(pulse: Pulse, register: Register) \u2192 Execution[Counter[str]] </p> <p>Submits the job to the backend and returns a processed MISSolution.</p> <p> Returns </p> <ul> <li> <p>Execution[Counter[str]] \u2014 The result of the execution.</p> </li> </ul>"},{"location":"api/mis/pipeline/fixtures/","title":"mis.pipeline.fixtures","text":"mis.pipeline.fixtures<p> source module mis.pipeline.fixtures </p> <p> Classes </p> <ul> <li> <p>Fixtures \u2014 Handles all preprocessing and postprocessing logic for MIS problems.</p> </li> </ul> <p> source class Fixtures(instance: MISInstance, config: SolverConfig) </p> <p>Handles all preprocessing and postprocessing logic for MIS problems.</p> <p>This class allows centralized transformation or validation of the problem instance before solving, and modification or annotation of the solution after solving.</p> <p>Initialize the fixture handler with the MIS instance and solver config.</p> <p> Parameters </p> <ul> <li> <p>instance :  MISInstance \u2014 The problem instance to process.</p> </li> <li> <p>config :  SolverConfig \u2014 Solver configuration, which may include flags for enabling or customizing processing behavior.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>preprocess \u2014 Apply preprocessing steps to the MIS instance before solving.</p> </li> <li> <p>rebuild \u2014 Apply any pending rebuild operations to convert solutions on preprocessed graphs into solutions on the original graph.</p> </li> <li> <p>postprocess</p> </li> </ul> <p> source method Fixtures.preprocess() \u2192 MISInstance </p> <p>Apply preprocessing steps to the MIS instance before solving.</p> <p> Returns </p> <ul> <li> <p>MISInstance \u2014 The processed or annotated instance.</p> </li> </ul> <p> source method Fixtures.rebuild(solution: MISSolution) \u2192 MISSolution </p> <p>Apply any pending rebuild operations to convert solutions on preprocessed graphs into solutions on the original graph.</p> <p> Parameters </p> <ul> <li> <p>solution :  MISSolution \u2014 The raw solution from a solver.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>MISSolution \u2014 The cleaned or transformed solution.</p> </li> </ul> <p> source method Fixtures.postprocess(solutions: list[MISSolution]) \u2192 list[MISSolution] </p>"},{"location":"api/mis/pipeline/kernelization/","title":"mis.pipeline.kernelization","text":"mis.pipeline.kernelization<p> source module mis.pipeline.kernelization </p> <p> Classes </p> <ul> <li> <p>BaseKernelization \u2014 Shared base class for kernelization.</p> </li> <li> <p>Kernelization \u2014 Apply well-known transformations to the graph to reduce its size without compromising the result.</p> </li> <li> <p>BaseRebuilder \u2014 The pre-processing operations attempt to remove edges and/or vertices from the original graph. Therefore, when we build a MIS for these reduced graphs (the \"partial solution\"), we may end up with a solution that does not work for the original graph.</p> </li> <li> <p>RebuilderIsolatedNodeRemoval</p> </li> <li> <p>RebuilderNodeFolding</p> </li> <li> <p>RebuilderUnconfined</p> </li> <li> <p>RebuilderTwinIndependent</p> </li> <li> <p>RebuilderTwinHasDependency</p> </li> </ul> <p> source class BaseKernelization(graph: nx.Graph) </p> <p>Bases : BasePreprocessor, abc.ABC</p> <p>Shared base class for kernelization.</p> <p> Methods </p> <ul> <li> <p>preprocess</p> </li> <li> <p>rebuild \u2014 Rebuild a MIS solution to the original graph from a partial MIS solution on the reduced graph obtained by kernelization.</p> </li> <li> <p>is_independent \u2014 Determine if a set of nodes represents an independent set within a given graph.</p> </li> <li> <p>is_subclique \u2014 Determine whether a list of nodes represents a clique within the graph, i.e. whether every pair of nodes is connected.</p> </li> <li> <p>is_isolated \u2014 Determine whether a node is isolated, i.e. this node + its neighbours represent a clique.</p> </li> </ul> <p> source method BaseKernelization.preprocess() \u2192 nx.Graph </p> <p> source method BaseKernelization.rebuild(partial_solution: set[int]) \u2192 set[int] </p> <p>Rebuild a MIS solution to the original graph from a partial MIS solution on the reduced graph obtained by kernelization.</p> <p> source method BaseKernelization.is_independent(nodes: list[int]) \u2192 bool </p> <p>Determine if a set of nodes represents an independent set within a given graph.</p> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the nodes in <code>nodes</code> represent an independent     set within <code>graph</code>. False otherwise, i.e. if there's at least one connection     between two nodes of <code>nodes</code></p> </li> </ul> <p> source method BaseKernelization.is_subclique(nodes: list[int]) \u2192 bool </p> <p>Determine whether a list of nodes represents a clique within the graph, i.e. whether every pair of nodes is connected.</p> <p> source method BaseKernelization.is_isolated(node: int) \u2192 bool </p> <p>Determine whether a node is isolated, i.e. this node + its neighbours represent a clique.</p> <p> source class Kernelization(graph: nx.Graph) </p> <p>Bases : BaseKernelization</p> <p>Apply well-known transformations to the graph to reduce its size without compromising the result.</p> <p> This algorithm is adapted from e.g. </p> <p>https://schulzchristian.github.io/thesis/masterarbeit_demian_hespe.pdf</p> <p> Methods </p> <ul> <li> <p>preprocess \u2014 Apply all rules, exhaustively, until the graph cannot be reduced further, storing the rules for rebuilding after the fact.</p> </li> <li> <p>apply_rule_isolated_node_removal</p> </li> <li> <p>search_rule_isolated_node_removal \u2014 Remove any isolated node (see <code>is_isolated</code> for a definition).</p> </li> <li> <p>apply_rule_node_fold</p> </li> <li> <p>search_rule_node_fold \u2014 If a node V has exactly two neighbours U and X and there is no edge between U and X, fold U, V and X and into a single node.</p> </li> <li> <p>aux_search_confinement</p> </li> <li> <p>apply_rule_unconfined</p> </li> <li> <p>unconfined_loop</p> </li> <li> <p>search_rule_unconfined_and_diamond</p> </li> <li> <p>fold_twin</p> </li> <li> <p>find_twin \u2014 Find a twin of a node, i.e. another node with the same neighbours.</p> </li> <li> <p>apply_rule_twin_independent</p> </li> <li> <p>apply_rule_twin_has_dependency</p> </li> <li> <p>search_rule_twin_reduction \u2014 If a node has exactly 3 neighbours and a twin (another node with the exact same neighbours), we can merge the 5 nodes.</p> </li> </ul> <p> source method Kernelization.preprocess() \u2192 nx.Graph </p> <p>Apply all rules, exhaustively, until the graph cannot be reduced further, storing the rules for rebuilding after the fact.</p> <p> source method Kernelization.apply_rule_isolated_node_removal(isolated: int) \u2192 None </p> <p> source method Kernelization.search_rule_isolated_node_removal() \u2192 None </p> <p>Remove any isolated node (see <code>is_isolated</code> for a definition).</p> <p> source method Kernelization.apply_rule_node_fold(v: int, u: int, x: int) \u2192 None </p> <p> source method Kernelization.search_rule_node_fold() \u2192 None </p> <p>If a node V has exactly two neighbours U and X and there is no edge between U and X, fold U, V and X and into a single node.</p> <p> source method Kernelization.aux_search_confinement(neighbors_S: set[int], S: set[int]) \u2192 tuple[int, int, set[int]] </p> <p> source method Kernelization.apply_rule_unconfined(v: int) \u2192 None </p> <p> source method Kernelization.unconfined_loop(v: int, S: set[int], neighbors_S: set[int]) \u2192 bool </p> <p> source method Kernelization.search_rule_unconfined_and_diamond() \u2192 None </p> <p> source method Kernelization.fold_twin(u: int, v: int, v_prime: int, neighbors_u: list[int]) \u2192 None </p> <p> source method Kernelization.find_twin(v: int) \u2192 int | None </p> <p>Find a twin of a node, i.e. another node with the same neighbours.</p> <p> source method Kernelization.apply_rule_twin_independent(v: int, u: int, neighbors_u: list[int]) \u2192 None </p> <p> source method Kernelization.apply_rule_twin_has_dependency(v: int, u: int, neighbors_u: list[int]) \u2192 None </p> <p> source method Kernelization.search_rule_twin_reduction() \u2192 None </p> <p>If a node has exactly 3 neighbours and a twin (another node with the exact same neighbours), we can merge the 5 nodes.</p> <p> source class BaseRebuilder() </p> <p>Bases : abc.ABC</p> <p>The pre-processing operations attempt to remove edges and/or vertices from the original graph. Therefore, when we build a MIS for these reduced graphs (the \"partial solution\"), we may end up with a solution that does not work for the original graph.</p> <p>Each rebuilder corresponds to one of the operations that previously reduced the size of the graph, and is charged with adapting the MIS solution to the greater graph.</p> <p> Methods </p> <ul> <li> <p>rebuild</p> </li> </ul> <p> source method BaseRebuilder.rebuild(partial_solution: set[int]) \u2192 None </p> <p> source class RebuilderIsolatedNodeRemoval(isolated: int) </p> <p>Bases : BaseRebuilder</p> <p> Methods </p> <ul> <li> <p>rebuild</p> </li> </ul> <p> source method RebuilderIsolatedNodeRemoval.rebuild(partial_solution: set[int]) \u2192 None </p> <p> source class RebuilderNodeFolding(v: int, u: int, x: int, v_prime: int) </p> <p>Bases : BaseRebuilder</p> <p> Methods </p> <ul> <li> <p>rebuild</p> </li> </ul> <p> source method RebuilderNodeFolding.rebuild(partial_solution: set[int]) \u2192 None </p> <p> source class RebuilderUnconfined() </p> <p>Bases : BaseRebuilder</p> <p> Methods </p> <ul> <li> <p>rebuild</p> </li> </ul> <p> source method RebuilderUnconfined.rebuild(partial_solution: set[int]) \u2192 None </p> <p> source class RebuilderTwinIndependent(v: int, u: int, w_0: int, w_1: int, w_2: int, v_prime: int) </p> <p>Bases : BaseRebuilder</p> <p> Invariants </p> <ul> <li>U has exactly 3 neighbours W0, W1, W2;</li> <li>V has exactly the same neighbours as U;</li> <li>there is no self-loop around U or V (hence U and V are not    neighbours);</li> <li>there is no edge between W1, W2, W3;</li> <li>V' is the node obtained by merging U, V, W1, W2, W3.</li> </ul> <p> Methods </p> <ul> <li> <p>rebuild</p> </li> </ul> <p> source method RebuilderTwinIndependent.rebuild(partial_solution: set[int]) \u2192 None </p> <p> source class RebuilderTwinHasDependency(v: int, u: int) </p> <p>Bases : BaseRebuilder</p> <p> Invariants </p> <ul> <li>U has exactly 3 neighbours;</li> <li>V has exactly the same neighbours as U;</li> <li>there is no self-loop around U;</li> <li>there is at least one connection between two neighbours of U.</li> </ul> <p> Methods </p> <ul> <li> <p>rebuild</p> </li> </ul> <p> source method RebuilderTwinHasDependency.rebuild(partial_solution: set[int]) \u2192 None </p>"},{"location":"api/mis/pipeline/layout/","title":"mis.pipeline.layout","text":"mis.pipeline.layout<p> source module mis.pipeline.layout </p> <p> Classes </p> <ul> <li> <p>Layout \u2014 A 2D layout class for quantum layout embedding.</p> </li> </ul> <p> source class Layout(data: MISInstance | dict[int, tuple[float, float]], rydberg_blockade: float) </p> <p>A 2D layout class for quantum layout embedding.</p> <p> Accepts either </p> <ul> <li>dict[int, tuple[float, float]] of coordinates     mapping from node (int) to physical coordinates (x, y)     UNIT = \"\u00b5m\"</li> <li>MISInstance (graph)</li> </ul> <p> Methods </p> <ul> <li> <p>from_device \u2014 Creates a Layout using <code>device.min_atom_distance</code> as the blockade, and rescales coordinates so no pair is too close.</p> </li> <li> <p>draw</p> </li> <li> <p>num_nodes</p> </li> <li> <p>grid_size</p> </li> </ul> <p> source classmethod Layout.from_device(data: MISInstance | dict[int, tuple[float, float]], device: Device) \u2192 Layout </p> <p>Creates a Layout using <code>device.min_atom_distance</code> as the blockade, and rescales coordinates so no pair is too close.</p> <p> source method Layout.draw() \u2192 None </p> <p> source method Layout.num_nodes() \u2192 int </p> <p> source method Layout.grid_size() \u2192 int </p>"},{"location":"api/mis/pipeline/maximization/","title":"mis.pipeline.maximization","text":"mis.pipeline.maximization<p> source module mis.pipeline.maximization </p> <p> Classes </p> <ul> <li> <p>Maximization \u2014 A postprocessor dedicated to improving MIS results provided by a quantum algorithm.</p> </li> </ul> <p> source class Maximization(frequency_threshold: float = 1e-07, augment_rounds: int = 10, seed: int = 0) </p> <p>Bases : BasePostprocessor</p> <p>A postprocessor dedicated to improving MIS results provided by a quantum algorithm.</p> <p>This postprocessor expects that a result could be vulnerable to bitflips, so it will attempt to fix any result provided by the quantum algorithm, to make it independent (if it's not independent) and maximal (if it's not maximal).</p> <p>frequency_threshold: Minimal frequency to check. Discard any solution which show     up with a frequency &lt;= frequency_threshold. Set 0 to never discard any solution. augment_rounds: The number of attempts to augment an independent set to     add possibly missing nodes. seed: A random seed.</p> <p> Methods </p> <ul> <li> <p>postprocess \u2014 The main entry point: attempt to improve a solution.</p> </li> <li> <p>is_independent_solution \u2014 Check whether a solution is independent.</p> </li> <li> <p>is_independent_list \u2014 Check whether a list of nodes within a graph is independent.</p> </li> <li> <p>augment_to_maximal \u2014 Augment a given set up to a maximal IS using a greedy algorithm running k times.</p> </li> <li> <p>reduce_to_independence \u2014 Reduce the given candidate solution to an independent state of graph g.</p> </li> </ul> <p> source method Maximization.postprocess(solution: MISSolution) \u2192 MISSolution | None </p> <p>The main entry point: attempt to improve a solution.</p> <p> source method Maximization.is_independent_solution(solution: MISSolution) \u2192 bool </p> <p>Check whether a solution is independent.</p> <p> source method Maximization.is_independent_list(graph: nx.Graph, nodes: list[int]) \u2192 bool </p> <p>Check whether a list of nodes within a graph is independent.</p> <p> source method Maximization.augment_to_maximal(solution: MISSolution) \u2192 MISSolution </p> <p>Augment a given set up to a maximal IS using a greedy algorithm running k times.</p> <p>See https://doi.org/10.48550/arXiv.2202.09372 section 2.3 of supplementary material for reference.</p> <p> source method Maximization.reduce_to_independence(solution: MISSolution) \u2192 MISSolution </p> <p>Reduce the given candidate solution to an independent state of graph g.</p> <p>We progressively remove the nodes with highest number of neighbours.</p> <p>See https://doi.org/10.48550/arXiv.2202.09372 section 2.3 of supplementary material for reference.</p>"},{"location":"api/mis/pipeline/postprocessor/","title":"mis.pipeline.postprocessor","text":"mis.pipeline.postprocessor<p> source module mis.pipeline.postprocessor </p> <p> Classes </p> <ul> <li> <p>BasePostprocessor</p> </li> </ul> <p> source class BasePostprocessor() </p> <p>Bases : abc.ABC</p> <p> Methods </p> <ul> <li> <p>postprocess \u2014 Post-process a solution, typically to improve its quality.</p> </li> </ul> <p> source method BasePostprocessor.postprocess(solution: MISSolution) \u2192 MISSolution | None </p> <p>Post-process a solution, typically to improve its quality.</p> <p>May return <code>None</code> if the solution is deemed unacceptable.</p>"},{"location":"api/mis/pipeline/preprocessor/","title":"mis.pipeline.preprocessor","text":"mis.pipeline.preprocessor<p> source module mis.pipeline.preprocessor </p> <p> Classes </p> <ul> <li> <p>BasePreprocessor \u2014 Base class for preprocessors.</p> </li> </ul> <p> source class BasePreprocessor() </p> <p>Bases : abc.ABC</p> <p>Base class for preprocessors.</p> <p> Methods </p> <ul> <li> <p>preprocess</p> </li> <li> <p>rebuild</p> </li> </ul> <p> source method BasePreprocessor.preprocess() \u2192 nx.Graph </p> <p> source method BasePreprocessor.rebuild(partial_solution: set[int]) \u2192 set[int] </p>"},{"location":"api/mis/pipeline/pulse/","title":"mis.pipeline.pulse","text":"mis.pipeline.pulse<p> source module mis.pipeline.pulse </p> <p> Classes </p> <ul> <li> <p>BasePulseShaper \u2014 Abstract base class for generating pulse schedules based on a MIS problem.</p> </li> <li> <p>DefaultPulseShaper \u2014 A simple pulse shaper.</p> </li> </ul> <p> source dataclass BasePulseShaper(duration_us: int | None = None) </p> <p>Bases : ABC</p> <p>Abstract base class for generating pulse schedules based on a MIS problem.</p> <p>This class transforms the structure of a MISInstance into a quantum pulse sequence that can be applied to a physical register. The register is passed at the time of pulse generation, not during initialization.</p> <p> Attributes </p> <ul> <li> <p>duration_us :  int | None \u2014 The duration of the pulse, in microseconds.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>generate \u2014 Generate a pulse based on the problem and the provided register.</p> </li> </ul> <p> source method BasePulseShaper.generate(config: SolverConfig, register: Register) \u2192 Pulse </p> <p>Generate a pulse based on the problem and the provided register.</p> <p> Parameters </p> <ul> <li> <p>config :  SolverConfig \u2014 The configuration for this pulse.</p> </li> <li> <p>register :  Register \u2014 The physical register layout.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Pulse \u2014 A generated pulse object wrapping a Pulser pulse.</p> </li> </ul> <p> source dataclass DefaultPulseShaper(duration_us: int | None = None) </p> <p>Bases : BasePulseShaper</p> <p>A simple pulse shaper.</p> <p> Attributes </p> <ul> <li> <p>duration_us :  int | None \u2014 The duration of the pulse, in microseconds.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>generate \u2014 Method to return a simple constant waveform pulse</p> </li> </ul> <p> source method DefaultPulseShaper.generate(config: SolverConfig, register: Register) \u2192 Pulse </p> <p>Method to return a simple constant waveform pulse</p>"},{"location":"api/mis/pipeline/targets/","title":"mis.pipeline.targets","text":"mis.pipeline.targets<p> source module mis.pipeline.targets </p> <p>Code emitted by compilation.</p> <p>In practice, this code is a very thin layer around Pulser's representation.</p> <p> Classes </p> <ul> <li> <p>Pulse \u2014 Specification of a laser pulse to be executed on a quantum device</p> </li> <li> <p>Register \u2014 Specification of a geometry of atoms to be executed on a quantum device</p> </li> </ul> <p> source dataclass Pulse(pulse: pulser.Pulse, detuning_maps: list[tuple[pulser.register.weight_maps.DetuningMap, pulser.waveforms.Waveform]] | None = None) </p> <p>Specification of a laser pulse to be executed on a quantum device</p> <p> Attributes </p> <ul> <li> <p>pulse :  pulser.Pulse \u2014 The low-level Pulser pulse.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>draw \u2014 Draw the shape of this laser pulse.</p> </li> </ul> <p> source method Pulse.draw() \u2192 None </p> <p>Draw the shape of this laser pulse.</p> <p> source dataclass Register(device: pulser.devices.Device, register: pulser.Register, graph: nx.Graph) </p> <p>Specification of a geometry of atoms to be executed on a quantum device</p> <p> Attributes </p> <ul> <li> <p>device :  pulser.devices.Device \u2014 The quantum device targeted.</p> </li> <li> <p>register :  pulser.Register \u2014 The low-level Pulser register.</p> </li> <li> <p>graph :  nx.Graph \u2014 The graph laid out as register. Note that this is not necessarily the same graph as in MISInstance, as it may have been transformed by some intermediate steps.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>draw \u2014 Draw the geometry of this register.</p> </li> </ul> <p> source method Register.draw() \u2192 None </p> <p>Draw the geometry of this register.</p>"},{"location":"api/mis/shared/","title":"mis.shared","text":"mis.shared<p> source package mis.shared </p> <p>Shared utility code.</p> <p> Modules </p> <ul> <li> <p>mis.shared.error \u2014 Exceptions raised within this library.</p> </li> <li> <p>mis.shared.graphs</p> </li> <li> <p>mis.shared.retrier \u2014 Backoff-and-retry utilities.</p> </li> <li> <p>mis.shared.types</p> </li> </ul>"},{"location":"api/mis/shared/error/","title":"mis.shared.error","text":"mis.shared.error<p> source module mis.shared.error </p> <p>Exceptions raised within this library.</p> <p> Classes </p> <ul> <li> <p>MappingError \u2014 An error raised when a graph-to-layout mapping fails validation, such as when node placements violate adjacency or physical layout constraints.</p> </li> <li> <p>CompilationError \u2014 An error raised when attempting to compile a graph for an architecture that does not support it, e.g. because it requires too many qubits or because the physical constraints on the geometry are not satisfied.</p> </li> <li> <p>ExecutionError</p> </li> </ul> <p> source class MappingError() </p> <p>Bases : ValueError</p> <p>An error raised when a graph-to-layout mapping fails validation, such as when node placements violate adjacency or physical layout constraints.</p> <p> source class CompilationError() </p> <p>Bases : Exception</p> <p>An error raised when attempting to compile a graph for an architecture that does not support it, e.g. because it requires too many qubits or because the physical constraints on the geometry are not satisfied.</p> <p> source class ExecutionError() </p> <p>Bases : Exception</p>"},{"location":"api/mis/shared/graphs/","title":"mis.shared.graphs","text":"mis.shared.graphs<p> source module mis.shared.graphs </p> <p> Functions </p> <ul> <li> <p>calculate_weight \u2014 Calculates the total weight of a set of nodes in a given MISInstance</p> </li> <li> <p>is_independent \u2014 Checks if the node set is an independent set (no edges between them).</p> </li> <li> <p>remove_neighborhood \u2014 Removes a node and all its neighbors from the graph.</p> </li> </ul> <p> source calculate_weight(graph: nx.Graph, nodes: list[int]) \u2192 float </p> <p>Calculates the total weight of a set of nodes in a given MISInstance</p> <p> Parameters </p> <ul> <li> <p>graph :  nx.Graph \u2014 The graph to check.</p> </li> <li> <p>nodes :  list[int] \u2014 List of node indices.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>float \u2014 Total weight as a float.</p> </li> </ul> <p> source is_independent(graph: nx.Graph, nodes: list[int]) \u2192 bool </p> <p>Checks if the node set is an independent set (no edges between them).</p> <p> Parameters </p> <ul> <li> <p>graph :  nx.Graph \u2014 The graph to check.</p> </li> <li> <p>nodes :  list[int] \u2014 The set of nodes.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if independent, False otherwise.</p> </li> </ul> <p> source remove_neighborhood(graph: nx.Graph, nodes: list[int]) \u2192 nx.Graph </p> <p>Removes a node and all its neighbors from the graph.</p> <p> Parameters </p> <ul> <li> <p>graph :  nx.Graph \u2014 The graph to modify.</p> </li> <li> <p>nodes :  list[int] \u2014 List of nodes to remove.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>nx.Graph \u2014 The reduced graph.</p> </li> </ul>"},{"location":"api/mis/shared/retrier/","title":"mis.shared.retrier","text":"mis.shared.retrier<p> source module mis.shared.retrier </p> <p>Backoff-and-retry utilities.</p> <p> Classes </p> <ul> <li> <p>PygRetrier \u2014 Our test harness attempts to run tests concurrently, but the pyg dataset loader does not work well with concurrency.</p> </li> </ul> <p> source class PygRetrier(max_attempts: int = 3, name: str = 'PygRetrier') </p> <p>Our test harness attempts to run tests concurrently, but the pyg dataset loader does not work well with concurrency.</p> <p>We work around this by simply retrying the loads a few times, until it succeeds.</p> <p>Create a PygRetrier</p> <p> Parameters </p> <ul> <li> <p>max_attempts :  optional \u2014 The max number of attempts to undertake before giving up. Defaults to 3.</p> </li> <li> <p>name :  optional \u2014 A name to use during logging.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>insist \u2014 Attempt to call a function or constructor repeatedly until, hopefully, it works.</p> </li> </ul> <p> source method PygRetrier.insist(callback: Type[Dataset], **kwargs: Any) \u2192 Dataset </p> <p>Attempt to call a function or constructor repeatedly until, hopefully, it works.</p> <p> Raises </p> <ul> <li> <p>exn</p> </li> </ul>"},{"location":"api/mis/shared/types/","title":"mis.shared.types","text":"mis.shared.types<p> source module mis.shared.types </p> <p> Classes </p> <ul> <li> <p>BackendType \u2014 Type of backend to use for solving the MIS</p> </li> <li> <p>MethodType</p> </li> <li> <p>MISInstance</p> </li> <li> <p>MISSolution</p> </li> </ul> <p> source enum BackendType() </p> <p>Bases : str, Enum</p> <p>Type of backend to use for solving the MIS</p> <p> Attributes </p> <ul> <li> <p>QUTIP</p> </li> <li> <p>REMOTE_QPU</p> </li> <li> <p>REMOTE_EMUMPS</p> </li> </ul> <p> source enum MethodType() </p> <p>Bases : str, Enum</p> <p> Attributes </p> <ul> <li> <p>EAGER</p> </li> <li> <p>GREEDY</p> </li> </ul> <p> source class MISInstance(graph: networkx.Graph) </p> <p> Methods </p> <ul> <li> <p>draw \u2014 Draw instance graph with highlighted nodes.</p> </li> </ul> <p> source method MISInstance.draw(nodes: list[int] | None = None, node_size: int = 600, highlight_color: str = 'red') \u2192 None </p> <p>Draw instance graph with highlighted nodes.</p> <p> Parameters </p> <ul> <li> <p>```</p> </li> <li> <p>nodes :  list[int] \u2014 List of nodes to highlight.</p> </li> <li> <p>node_size :  int \u2014 Size of drawn nodes in drawn graph. (default: 600)</p> </li> <li> <p>highlight_color :  str \u2014 Color to highlight nodes with. (default: \"red\")</p> </li> <li> <p>```</p> </li> </ul> <p> Raises </p> <ul> <li> <p>Exception</p> </li> </ul> <p> source dataclass MISSolution(original: networkx.Graph, nodes: list[int], frequency: float) </p> <p> Methods </p> <ul> <li> <p>draw \u2014 Draw instance graph with solution nodes highlighted.</p> </li> </ul> <p> source method MISSolution.draw(node_size: int = 600, highlight_color: str = 'red') \u2192 None </p> <p>Draw instance graph with solution nodes highlighted.</p> <p> Parameters </p> <ul> <li> <p>```</p> </li> <li> <p>node_size :  int \u2014 Size of drawn nodes in drawn graph. (default: 600)</p> </li> <li> <p>highlight_color :  str \u2014 Color to highlight nodes with. (default: \"red\")</p> </li> <li> <p>```</p> </li> </ul>"}]}